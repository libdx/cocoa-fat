//
//  This file is part of a five file concatenation of the CwlViews_iOS
//  framework with internal interfaces for source inclusion in projects instead
//  of library inclusion.
//  For details, visit: https://github.com/mattgallagher/CwlViews
//
//  Copyright Â© 2015-2017 Matt Gallagher ( http://cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlUtilsConcat tool on 2018-03-17 06:51:19 +0000 from the following files:
//
//    CwlSwipeGestureRecognizer.swift
//    CwlSetOrAnimate.swift
//    CwlTapGestureRecognizer.swift
//    CwlBarItem.swift
//    CwlLabel.swift
//    CwlTableSection.swift
//    CwlNavigationItem.swift
//    CwlTabBar.swift
//    CwlTabBarController.swift
//    CwlImageView.swift
//    CwlAlertController.swift
//    CwlTableViewCell.swift
//    CwlTabBarItem.swift
//    CwlLongPressGestureRecognizer.swift
//    CwlAlertAction.swift
//    CwlSlider.swift
//    CwlWindow.swift
//    CwlSwitch.swift
//    CwlPanGestureRecognizer.swift
//    CwlPinchGestureRecognizer.swift
//    CwlControl.swift
//    CwlTextInputTraits.swift
//    CwlSearchBar.swift
//    CwlScreenEdgePanGestureRecognizer.swift
//    CwlRotationGestureRecognizer.swift
//

import UIKit

// MARK: ### CwlSwipeGestureRecognizer.swift ###

class SwipeGestureRecognizer: ConstructingBinder, SwipeGestureRecognizerInstance {
	typealias Instance = UISwipeGestureRecognizer
	typealias Inherited = GestureRecognizer
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var swipeGestureRecognizerInstance: Instance { return instance() }
	
	enum Binding: SwipeGestureRecognizerBinding {
		typealias Binder = SwipeGestureRecognizer
		static func swipeGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case direction(DynamicValue<UISwipeGestureRecognizerDirection>)
		case numberOfTouchesRequired(DynamicValue<Int>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = SwipeGestureRecognizer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .direction(let x): return x.apply(instance, storage) { i, s, v in i.direction = v }
			case .numberOfTouchesRequired(let x): return x.apply(instance, storage) { i, s, v in i.numberOfTouchesRequired = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: SwipeGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .swipeGestureRecognizerBinding(SwipeGestureRecognizer.Binding.$1(v)) }) }
	static var direction: BindingName<DynamicValue<UISwipeGestureRecognizerDirection>, Binding> { return BindingName<DynamicValue<UISwipeGestureRecognizerDirection>, Binding>({ v in .swipeGestureRecognizerBinding(SwipeGestureRecognizer.Binding.direction(v)) }) }
	static var numberOfTouchesRequired: BindingName<DynamicValue<Int>, Binding> { return BindingName<DynamicValue<Int>, Binding>({ v in .swipeGestureRecognizerBinding(SwipeGestureRecognizer.Binding.numberOfTouchesRequired(v)) }) }
}

protocol SwipeGestureRecognizerInstance: GestureRecognizerInstance {
	var swipeGestureRecognizerInstance: SwipeGestureRecognizer.Instance { get }
}
extension SwipeGestureRecognizerInstance {
	var gestureRecognizerInstance: GestureRecognizer.Instance { return swipeGestureRecognizerInstance }
}
extension SwipeGestureRecognizer.Instance: SwipeGestureRecognizerInstance {
	var swipeGestureRecognizerInstance: SwipeGestureRecognizer.Instance { return self }
}

protocol SwipeGestureRecognizerBinding: GestureRecognizerBinding {
	static func swipeGestureRecognizerBinding(_ binding: SwipeGestureRecognizer.Binding) -> Self
}
extension SwipeGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return Self.swipeGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlSetOrAnimate.swift ###

/// A value abstraction of the arguments to some AppKit/UIKit methods with a `setValue(_:,animated:)` structure.
struct SetOrAnimate<Value> {
	let value: Value
	let isAnimated: Bool
	
	static func set(_ value: Value) -> SetOrAnimate<Value> {
		return SetOrAnimate<Value>(value: value, isAnimated: false)
	}
	static func animate(_ value: Value) -> SetOrAnimate<Value> {
		return SetOrAnimate<Value>(value: value, isAnimated: true)
	}
}

extension SignalInterface {
	/// A signal transformation which wraps the output in `SetOrAnimate` with the first value as in `set` but subsequent values as in `animate`
	func animate(_ choice: AnimationChoice = .subsequent) -> Signal<SetOrAnimate<OutputValue>> {
		return map(initialState: false) { (alreadyReceived: inout Bool, value: OutputValue) in
			if alreadyReceived || choice == .all {
				return .animate(value)
			} else {
				if choice == .subsequent {
					alreadyReceived = true
				}
				return .set(value)
			}
		}
	}
}

// MARK: ### CwlTapGestureRecognizer.swift ###

class TapGestureRecognizer: ConstructingBinder, TapGestureRecognizerInstance {
	typealias Instance = UITapGestureRecognizer
	typealias Inherited = GestureRecognizer
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var tapGestureRecognizerInstance: Instance { return instance() }
	
	enum Binding: TapGestureRecognizerBinding {
		typealias Binder = TapGestureRecognizer
		static func tapGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case numberOfTapsRequired(DynamicValue<Int>)
		case numberOfTouchesRequired(DynamicValue<Int>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = TapGestureRecognizer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .numberOfTapsRequired(let x): return x.apply(instance, storage) { i, s, v in i.numberOfTapsRequired = v }
			case .numberOfTouchesRequired(let x): return x.apply(instance, storage) { i, s, v in i.numberOfTouchesRequired = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: TapGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .tapGestureRecognizerBinding(TapGestureRecognizer.Binding.$1(v)) }) }
	static var numberOfTapsRequired: BindingName<DynamicValue<Int>, Binding> { return BindingName<DynamicValue<Int>, Binding>({ v in .tapGestureRecognizerBinding(TapGestureRecognizer.Binding.numberOfTapsRequired(v)) }) }
	static var numberOfTouchesRequired: BindingName<DynamicValue<Int>, Binding> { return BindingName<DynamicValue<Int>, Binding>({ v in .tapGestureRecognizerBinding(TapGestureRecognizer.Binding.numberOfTouchesRequired(v)) }) }
}

protocol TapGestureRecognizerInstance: GestureRecognizerInstance {
	var tapGestureRecognizerInstance: TapGestureRecognizer.Instance { get }
}
extension TapGestureRecognizerInstance {
	var gestureRecognizerInstance: GestureRecognizer.Instance { return tapGestureRecognizerInstance }
}
extension TapGestureRecognizer.Instance: TapGestureRecognizerInstance {
	var tapGestureRecognizerInstance: TapGestureRecognizer.Instance { return self }
}

protocol TapGestureRecognizerBinding: GestureRecognizerBinding {
	static func tapGestureRecognizerBinding(_ binding: TapGestureRecognizer.Binding) -> Self
}
extension TapGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return Self.tapGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlBarItem.swift ###

class BarItem: ConstructingBinder, BarItemInstance {
	typealias Instance = UIBarItem
	typealias Inherited = BaseBinder
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var barItemInstance: Instance { return instance() }
	
	enum Binding: BarItemBinding {
		typealias Binder = BarItem
		static func barItemBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case isEnabled(DynamicValue<Bool>)
		case image(DynamicValue<UIImage?>)
		case landscapeImagePhone(DynamicValue<UIImage?>)
		case imageInsets(DynamicValue<UIEdgeInsets>)
		case landscapeImagePhoneInsets(DynamicValue<UIEdgeInsets>)
		case title(DynamicValue<String>)
		case tag(DynamicValue<Int>)
		case titleTextAttributes(DynamicValue<ScopedValues<UIControlState, [NSAttributedStringKey: Any]>>)

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}

	struct Preparer: ConstructingPreparer {
		typealias Binder = BarItem
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }
		
		init() {}

		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .isEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isEnabled = v }
			case .image(let x): return x.apply(instance, storage) { i, s, v in i.image = v }
			case .landscapeImagePhone(let x): return x.apply(instance, storage) { i, s, v in i.landscapeImagePhone = v }
			case .imageInsets(let x): return x.apply(instance, storage) { i, s, v in i.imageInsets = v }
			case .landscapeImagePhoneInsets(let x): return x.apply(instance, storage) { i, s, v in i.landscapeImagePhoneInsets = v }
			case .title(let x): return x.apply(instance, storage) { i, s, v in i.title = v }
			case .tag(let x): return x.apply(instance, storage) { i, s, v in i.tag = v }
			case .titleTextAttributes(let x):
				var previous: ScopedValues<UIControlState, [NSAttributedStringKey: Any]>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitleTextAttributes([:], for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitleTextAttributes(c.1, for: c.0)
					}
				}
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: (), storage: ())
			}
		}
	}

	typealias Storage = ObjectBinderStorage
}

extension BindingName where Binding: BarItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .barItemBinding(BarItem.Binding.$1(v)) }) }
	static var isEnabled: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .barItemBinding(BarItem.Binding.isEnabled(v)) }) }
	static var image: BindingName<DynamicValue<UIImage?>, Binding> { return BindingName<DynamicValue<UIImage?>, Binding>({ v in .barItemBinding(BarItem.Binding.image(v)) }) }
	static var landscapeImagePhone: BindingName<DynamicValue<UIImage?>, Binding> { return BindingName<DynamicValue<UIImage?>, Binding>({ v in .barItemBinding(BarItem.Binding.landscapeImagePhone(v)) }) }
	static var imageInsets: BindingName<DynamicValue<UIEdgeInsets>, Binding> { return BindingName<DynamicValue<UIEdgeInsets>, Binding>({ v in .barItemBinding(BarItem.Binding.imageInsets(v)) }) }
	static var landscapeImagePhoneInsets: BindingName<DynamicValue<UIEdgeInsets>, Binding> { return BindingName<DynamicValue<UIEdgeInsets>, Binding>({ v in .barItemBinding(BarItem.Binding.landscapeImagePhoneInsets(v)) }) }
	static var title: BindingName<DynamicValue<String>, Binding> { return BindingName<DynamicValue<String>, Binding>({ v in .barItemBinding(BarItem.Binding.title(v)) }) }
	static var tag: BindingName<DynamicValue<Int>, Binding> { return BindingName<DynamicValue<Int>, Binding>({ v in .barItemBinding(BarItem.Binding.tag(v)) }) }
	static var titleTextAttributes: BindingName<DynamicValue<ScopedValues<UIControlState, [NSAttributedStringKey: Any]>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIControlState, [NSAttributedStringKey: Any]>>, Binding>({ v in .barItemBinding(BarItem.Binding.titleTextAttributes(v)) }) }
}

protocol BarItemInstance {
	var barItemInstance: BarItem.Instance { get }
}
extension BarItem.Instance: BarItemInstance {
	var barItemInstance: BarItem.Instance { return self }
}

protocol BarItemBinding: BaseBinding {
	static func barItemBinding(_ binding: BarItem.Binding) -> Self
}
extension BarItemBinding {
	static func baseBinderBinding(_ binding: BaseBinder.Binding) -> Self {
		return Self.barItemBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlLabel.swift ###

class Label: ConstructingBinder, LabelInstance {
	typealias Instance = UILabel
	typealias Inherited = View
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var labelInstance: Instance { return instance() }
	
	enum Binding: LabelBinding {
		typealias Binder = Label
		static func labelBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case text(DynamicValue<String>)
		case attributedText(DynamicValue<NSAttributedString?>)
		case font(DynamicValue<UIFont>)
		case textColor(DynamicValue<UIColor>)
		case textAlignment(DynamicValue<NSTextAlignment>)
		case lineBreakMode(DynamicValue<NSLineBreakMode>)
		case isEnabled(DynamicValue<Bool>)
		case adjustsFontSizeToFitWidth(DynamicValue<Bool>)
		case allowsDefaultTighteningForTruncation(DynamicValue<Bool>)
		case baselineAdjustment(DynamicValue<UIBaselineAdjustment>)
		case minimumScaleFactor(DynamicValue<CGFloat>)
		case numberOfLines(DynamicValue<Int>)
		case highlightedTextColor(DynamicValue<UIColor?>)
		case isHighlighted(DynamicValue<Bool>)
		case shadowColor(DynamicValue<UIColor?>)
		case shadowOffset(DynamicValue<CGSize>)
		case preferredMaxLayoutWidth(DynamicValue<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = Label
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .text(let x): return x.apply(instance, storage) { i, s, v in i.text = v }
			case .attributedText(let x): return x.apply(instance, storage) { i, s, v in i.attributedText = v }
			case .font(let x): return x.apply(instance, storage) { i, s, v in i.font = v }
			case .textColor(let x): return x.apply(instance, storage) { i, s, v in i.textColor = v }
			case .textAlignment(let x): return x.apply(instance, storage) { i, s, v in i.textAlignment = v }
			case .lineBreakMode(let x): return x.apply(instance, storage) { i, s, v in i.lineBreakMode = v }
			case .isEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isEnabled = v }
			case .adjustsFontSizeToFitWidth(let x): return x.apply(instance, storage) { i, s, v in i.adjustsFontSizeToFitWidth = v }
			case .allowsDefaultTighteningForTruncation(let x): return x.apply(instance, storage) { i, s, v in i.allowsDefaultTighteningForTruncation = v }
			case .baselineAdjustment(let x): return x.apply(instance, storage) { i, s, v in i.baselineAdjustment = v }
			case .minimumScaleFactor(let x): return x.apply(instance, storage) { i, s, v in i.minimumScaleFactor = v }
			case .numberOfLines(let x): return x.apply(instance, storage) { i, s, v in i.numberOfLines = v }
			case .highlightedTextColor(let x): return x.apply(instance, storage) { i, s, v in i.highlightedTextColor = v }
			case .isHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.isHighlighted = v }
			case .shadowColor(let x): return x.apply(instance, storage) { i, s, v in i.shadowColor = v }
			case .shadowOffset(let x): return x.apply(instance, storage) { i, s, v in i.shadowOffset = v }
			case .preferredMaxLayoutWidth(let x): return x.apply(instance, storage) { i, s, v in i.preferredMaxLayoutWidth = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = View.Storage
}

extension BindingName where Binding: LabelBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .labelBinding(Label.Binding.$1(v)) }) }
	static var text: BindingName<DynamicValue<String>, Binding> { return BindingName<DynamicValue<String>, Binding>({ v in .labelBinding(Label.Binding.text(v)) }) }
	static var attributedText: BindingName<DynamicValue<NSAttributedString?>, Binding> { return BindingName<DynamicValue<NSAttributedString?>, Binding>({ v in .labelBinding(Label.Binding.attributedText(v)) }) }
	static var font: BindingName<DynamicValue<UIFont>, Binding> { return BindingName<DynamicValue<UIFont>, Binding>({ v in .labelBinding(Label.Binding.font(v)) }) }
	static var textColor: BindingName<DynamicValue<UIColor>, Binding> { return BindingName<DynamicValue<UIColor>, Binding>({ v in .labelBinding(Label.Binding.textColor(v)) }) }
	static var textAlignment: BindingName<DynamicValue<NSTextAlignment>, Binding> { return BindingName<DynamicValue<NSTextAlignment>, Binding>({ v in .labelBinding(Label.Binding.textAlignment(v)) }) }
	static var lineBreakMode: BindingName<DynamicValue<NSLineBreakMode>, Binding> { return BindingName<DynamicValue<NSLineBreakMode>, Binding>({ v in .labelBinding(Label.Binding.lineBreakMode(v)) }) }
	static var isEnabled: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .labelBinding(Label.Binding.isEnabled(v)) }) }
	static var adjustsFontSizeToFitWidth: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .labelBinding(Label.Binding.adjustsFontSizeToFitWidth(v)) }) }
	static var allowsDefaultTighteningForTruncation: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .labelBinding(Label.Binding.allowsDefaultTighteningForTruncation(v)) }) }
	static var baselineAdjustment: BindingName<DynamicValue<UIBaselineAdjustment>, Binding> { return BindingName<DynamicValue<UIBaselineAdjustment>, Binding>({ v in .labelBinding(Label.Binding.baselineAdjustment(v)) }) }
	static var minimumScaleFactor: BindingName<DynamicValue<CGFloat>, Binding> { return BindingName<DynamicValue<CGFloat>, Binding>({ v in .labelBinding(Label.Binding.minimumScaleFactor(v)) }) }
	static var numberOfLines: BindingName<DynamicValue<Int>, Binding> { return BindingName<DynamicValue<Int>, Binding>({ v in .labelBinding(Label.Binding.numberOfLines(v)) }) }
	static var highlightedTextColor: BindingName<DynamicValue<UIColor?>, Binding> { return BindingName<DynamicValue<UIColor?>, Binding>({ v in .labelBinding(Label.Binding.highlightedTextColor(v)) }) }
	static var isHighlighted: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .labelBinding(Label.Binding.isHighlighted(v)) }) }
	static var shadowColor: BindingName<DynamicValue<UIColor?>, Binding> { return BindingName<DynamicValue<UIColor?>, Binding>({ v in .labelBinding(Label.Binding.shadowColor(v)) }) }
	static var shadowOffset: BindingName<DynamicValue<CGSize>, Binding> { return BindingName<DynamicValue<CGSize>, Binding>({ v in .labelBinding(Label.Binding.shadowOffset(v)) }) }
	static var preferredMaxLayoutWidth: BindingName<DynamicValue<CGFloat>, Binding> { return BindingName<DynamicValue<CGFloat>, Binding>({ v in .labelBinding(Label.Binding.preferredMaxLayoutWidth(v)) }) }
}

protocol LabelInstance: ViewInstance {
	var labelInstance: Label.Instance { get }
}
extension LabelInstance {
	var viewInstance: View.Instance { return labelInstance }
}
extension Label.Instance: LabelInstance {
	var labelInstance: Label.Instance { return self }
}

protocol LabelBinding: ViewBinding {
	static func labelBinding(_ binding: Label.Binding) -> Self
}

extension LabelBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return Self.labelBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlTableSection.swift ###

/// Storage for the string data associated with a `UITableView` section.
struct TableSectionMetadata {
	let header: String?
	let footer: String?
	init(header: String? = nil, footer: String? = nil) {
		(self.header, self.footer) = (header, footer)
	}
}

/// This data type models the most recent change to a section of a `UITableView`. When used as the `Value` type for a `TableRowMutation`, the combined data type can model all the section, header, footer and row data of an entire `UITableView`.
struct TableSectionMutation<Value>: ExpressibleByArrayLiteral {
	let metadata: TableSectionMetadata?
	let rowMutation: TableRowMutation<Value>

	init(metadata: TableSectionMetadata?, rowMutation: TableRowMutation<Value>) {
		self.metadata = metadata
		self.rowMutation = rowMutation
	}
	
	init(header: String? = nil, footer: String? = nil, rowMutation: TableRowMutation<Value>) {
		let metadata = header != nil || footer != nil ? TableSectionMetadata(header: header, footer: footer) : nil
		self.init(metadata: metadata, rowMutation: rowMutation)
	}
	
	init(arrayLiteral elements: Value...) {
		self.init(rowMutation: TableRowMutation(array: elements))
	}
	
	init() {
		self.init(rowMutation: TableRowMutation())
	}
}

/// A data type that can be used to cache the destination end of a `TableSectionMutation<Value>` change stream.
struct TableSectionState<Value> {
	var rowState = TableRowState<Value>()
	var metadata: TableSectionMetadata
	
	init(initial: TableSectionMutation<Value>) {
		self.metadata = initial.metadata ?? TableSectionMetadata()
		initial.rowMutation.apply(to: &rowState)
	}
	
	var rows: Deque<Value> {
		get {
			return rowState.rows
		} set {
			rowState.rows = newValue
		}
	}
	
	var localOffset: Int {
		get {
			return rowState.localOffset
		} set {
			rowState.localOffset = newValue
		}
	}
	
	var globalCount: Int {
		get {
			return rowState.globalCount
		} set {
			rowState.globalCount = newValue
		}
	}
}

/// An extension of the same premise in `TableRowMutation.apply` for `TableRowMutation<TableSectionMutation<Value>>` that maps the `TableSectionMutation` onto a `TableSectionState` and correctly applies the mutation in the nested `TableSectionMutation` to the target on update.
extension TableRowMutation {
	func apply<Row>(to sections: inout TableRowState<TableSectionState<Row>>) where TableSectionMutation<Row> == Value {
		sections.globalCount = self.globalCount
		sections.localOffset = self.localOffset
		let indexSet = self.arrayMutation.indexSet
		let values = self.arrayMutation.values
		switch self.arrayMutation.kind {
		case .delete:
			indexSet.rangeView.reversed().forEach { sections.rows.removeSubrange($0) }
		case .scroll(let offset):
			sections.rows.removeSubrange(offset > 0 ? sections.rows.startIndex..<offset : (sections.rows.endIndex + offset)..<sections.rows.endIndex)
			sections.rows.insert(contentsOf: values.map { TableSectionState<Row>(initial: $0) }, at: offset > 0 ? sections.rows.endIndex : sections.rows.startIndex)
		case .move(let index):
			let moving = indexSet.map { sections.rows[$0] }
			indexSet.rangeView.reversed().forEach { sections.rows.removeSubrange($0) }
			sections.rows.insert(contentsOf: moving, at: index)
		case .insert:
			for (i, v) in zip(indexSet, values) {
				sections.rows.insert(TableSectionState<Row>(initial: v), at: i)
			}
		case .update:
			for (valuesIndex, sectionIndex) in indexSet.enumerated() {
				var section = sections.rows[sectionIndex]
				let mutation = values[valuesIndex]
				if let m = mutation.metadata {
					section.metadata = m
				}
				mutation.rowMutation.apply(to: &section.rowState)
				sections.rows.replaceSubrange(sectionIndex..<(sectionIndex + 1), with: CollectionOfOne(section))
			}
		case .reload:
			sections.rows.replaceSubrange(sections.rows.startIndex..<sections.rows.endIndex, with: values.map { TableSectionState<Row>(initial: $0) })
		}
	}
}


// MARK: ### CwlNavigationItem.swift ###

class NavigationItem: ConstructingBinder, NavigationItemInstance {
	typealias Instance = UINavigationItem
	typealias Inherited = BaseBinder
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var navigationItemInstance: Instance { return instance() }
	
	enum Binding: NavigationItemBinding {
		typealias Binder = NavigationItem
		static func navigationItemBinding(_ binding: Binding) -> Binding { return binding }
	  case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case title(DynamicValue<String>)
		case titleView(DynamicValue<ViewInstance?>)
		case prompt(DynamicValue<String?>)
		case backBarButtonItem(DynamicValue<BarButtonItemInstance?>)
		case hidesBackButton(DynamicValue<SetOrAnimate<Bool>>)
		case leftBarButtonItems(DynamicValue<SetOrAnimate<[BarButtonItemInstance]>>)
		case rightBarButtonItems(DynamicValue<SetOrAnimate<[BarButtonItemInstance]>>)
		case leftItemsSupplementBackButton(DynamicValue<Bool>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

	  // 4. Delegate bindings require synchronous evaluation within the object's context.
	}

	struct Preparer: ConstructingPreparer {
		typealias Binder = NavigationItem
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .title(let x): return x.apply(instance, storage) { i, s, v in i.title = v }
			case .titleView(let x): return x.apply(instance, storage) { i, s, v in i.titleView = v?.viewInstance }
			case .prompt(let x): return x.apply(instance, storage) { i, s, v in i.prompt = v }
			case .backBarButtonItem(let x): return x.apply(instance, storage) { i, s, v in i.backBarButtonItem = v?.barButtonItemInstance }
			case .hidesBackButton(let x): return x.apply(instance, storage) { i, s, v in i.setHidesBackButton(v.value, animated: v.isAnimated) }
			case .leftBarButtonItems(let x): return x.apply(instance, storage) { i, s, v in i.setLeftBarButtonItems(v.value.map { $0.barButtonItemInstance }, animated: v.isAnimated) }
			case .rightBarButtonItems(let x): return x.apply(instance, storage) { i, s, v in i.setRightBarButtonItems(v.value.map { $0.barButtonItemInstance }, animated: v.isAnimated) }
			case .leftItemsSupplementBackButton(let x): return x.apply(instance, storage) { i, s, v in i.leftItemsSupplementBackButton = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: (), storage: ())
			}
		}
	}

	typealias Storage = ObjectBinderStorage
}

extension BindingName where Binding: NavigationItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.$1(v)) }) }
	static var title: BindingName<DynamicValue<String>, Binding> { return BindingName<DynamicValue<String>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.title(v)) }) }
	static var titleView: BindingName<DynamicValue<ViewInstance?>, Binding> { return BindingName<DynamicValue<ViewInstance?>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.titleView(v)) }) }
	static var prompt: BindingName<DynamicValue<String?>, Binding> { return BindingName<DynamicValue<String?>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.prompt(v)) }) }
	static var backBarButtonItem: BindingName<DynamicValue<BarButtonItemInstance?>, Binding> { return BindingName<DynamicValue<BarButtonItemInstance?>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.backBarButtonItem(v)) }) }
	static var hidesBackButton: BindingName<DynamicValue<SetOrAnimate<Bool>>, Binding> { return BindingName<DynamicValue<SetOrAnimate<Bool>>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.hidesBackButton(v)) }) }
	static var leftBarButtonItems: BindingName<DynamicValue<SetOrAnimate<[BarButtonItemInstance]>>, Binding> { return BindingName<DynamicValue<SetOrAnimate<[BarButtonItemInstance]>>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.leftBarButtonItems(v)) }) }
	static var rightBarButtonItems: BindingName<DynamicValue<SetOrAnimate<[BarButtonItemInstance]>>, Binding> { return BindingName<DynamicValue<SetOrAnimate<[BarButtonItemInstance]>>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.rightBarButtonItems(v)) }) }
	static var leftItemsSupplementBackButton: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.leftItemsSupplementBackButton(v)) }) }
}

protocol NavigationItemInstance {
	var navigationItemInstance: NavigationItem.Instance { get }
}
extension NavigationItem.Instance: NavigationItemInstance {
	var navigationItemInstance: NavigationItem.Instance { return self }
}

protocol NavigationItemBinding: BaseBinding {
	static func navigationItemBinding(_ binding: NavigationItem.Binding) -> Self
}
extension NavigationItemBinding {
	static func baseBinderBinding(_ binding: BaseBinder.Binding) -> Self {
		return Self.navigationItemBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlTabBar.swift ###

import UIKit

class TabBar<ItemIdentifier: Hashable>: ConstructingBinder, TabBarInstance {
	typealias Instance = UITabBar
	typealias Inherited = View
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var tabBarInstance: Instance { return instance() }
	
	enum Binding: TabBarBinding {
		typealias ItemIdentifierType = ItemIdentifier
		typealias Binder = TabBar
		static func tabBarBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case items(DynamicValue<SetOrAnimate<[ItemIdentifier]>>)
		case barStyle(DynamicValue<UIBarStyle>)
		case isTranslucent(DynamicValue<Bool>)
		case barTintColor(DynamicValue<UIColor>)
		case tintColor(DynamicValue<UIColor>)
		@available(iOS 10.0, *)
		case unselectedItemTintColor(DynamicValue<UIColor>)
		case backgroundImage(DynamicValue<UIImage?>)
		case shadowImage(DynamicValue<UIImage?>)
		case selectionIndicatorImage(DynamicValue<UIImage?>)
		case itemPositioning(DynamicValue<UITabBarItemPositioning>)
		case itemSpacing(DynamicValue<CGFloat>)
		case itemWidth(DynamicValue<CGFloat>)

		// 2. Signal bindings are performed on the object after construction.
		case selectItem(Signal<ItemIdentifier>)
		case customizingItems(Signal<SetOrAnimate<[ItemIdentifier]?>>)

		// 3. Action bindings are triggered by the object after construction.
		case willBeginCustomizing(SignalInput<[ItemIdentifier]>)
		case didBeginCustomizing(SignalInput<[ItemIdentifier]>)
		case willEndCustomizing(SignalInput<([ItemIdentifier], Bool)>)
		case didEndCustomizing(SignalInput<([ItemIdentifier], Bool)>)
		case didSelectItem(SignalInput<ItemIdentifier>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case itemConstructor((ItemIdentifier) -> TabBarItemInstance)
	}

	struct Preparer: ConstructingPreparer {
		typealias Binder = TabBar
		var linkedPreparer = Inherited.Preparer()

		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }

		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		var tabBarItemConstructor: ((ItemIdentifier) -> TabBarItemInstance)?

		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .itemConstructor(let x): tabBarItemConstructor = x
			case .willBeginCustomizing(let x):
				let s = #selector(UITabBarDelegate.tabBar(_:willBeginCustomizing:))
				delegate().addSelector(s).willBeginCustomizing = x
			case .didBeginCustomizing(let x):
				let s = #selector(UITabBarDelegate.tabBar(_:didBeginCustomizing:))
				delegate().addSelector(s).didBeginCustomizing = x
			case .willEndCustomizing(let x):
				let s = #selector(UITabBarDelegate.tabBar(_:willEndCustomizing:changed:))
				delegate().addSelector(s).willEndCustomizing = x
			case .didEndCustomizing(let x):
				let s = #selector(UITabBarDelegate.tabBar(_:didEndCustomizing:changed:))
				delegate().addSelector(s).didEndCustomizing = x
			case .didSelectItem(let x):
				let s = #selector(UITabBarDelegate.tabBar(_:didSelect:))
				delegate().addSelector(s).didSelectIndex = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")

			storage.dynamicDelegate = possibleDelegate
			storage.tabBarItemConstructor = tabBarItemConstructor
			
			if storage.inUse {
				instance.delegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			// e.g. case .someProperty(let x): return x.apply(instance, storage) { inst, stor, val in inst.someProperty = val }
			case .itemConstructor: return nil
			case .items(let x):
				return x.apply(instance, storage) { inst, stor, val in
					let items = val.value.compactMap { stor.tabBarItem(for: $0) }
					inst.setItems(items, animated: val.isAnimated)
				}
			case .selectItem(let x): return x.apply(instance, storage) { inst, stor, val in inst.selectedItem = stor.tabBarItem(for: val) }
			case .barStyle(let x): return x.apply(instance, storage) { inst, stor, val in inst.barStyle = val }
			case .isTranslucent(let x): return x.apply(instance, storage) { inst, stor, val in inst.isTranslucent = val }
			case .barTintColor(let x): return x.apply(instance, storage) { inst, stor, val in inst.barTintColor = val }
			case .tintColor(let x): return x.apply(instance, storage) { inst, stor, val in inst.tintColor = val }
			case .unselectedItemTintColor(let x): return x.apply(instance, storage) { inst, stor, val in
					if #available(iOS 10.0, *) {
						inst.unselectedItemTintColor = val
					}
				}
			case .backgroundImage(let x): return x.apply(instance, storage) { inst, stor, val in inst.backgroundImage = val }
			case .shadowImage(let x): return x.apply(instance, storage) { inst, stor, val in inst.shadowImage = val }
			case .selectionIndicatorImage(let x): return x.apply(instance, storage) { inst, stor, val in inst.selectionIndicatorImage = val }
			case .itemPositioning(let x): return x.apply(instance, storage) { inst, stor, val in inst.itemPositioning = val }
			case .itemSpacing(let x): return x.apply(instance, storage) { inst, stor, val in inst.itemSpacing = val }
			case .itemWidth(let x): return x.apply(instance, storage) { inst, stor, val in inst.itemWidth = val }
			case .customizingItems(let x): return x.apply(instance, storage) { inst, stor, val in
				if let v = val.value {
					let items = v.compactMap { stor.tabBarItem(for: $0) }
					inst.beginCustomizingItems(items)
				} else {
					inst.endCustomizing(animated: val.isAnimated)
				}
			}
			case .willBeginCustomizing: return nil
			case .didBeginCustomizing: return nil
			case .willEndCustomizing: return nil
			case .didEndCustomizing: return nil
			case .didSelectItem: return nil
			case .inheritedBinding(let b): return linkedPreparer.applyBinding(b, instance: instance, storage: storage)
			}
		}
	}

	class Storage: View.Storage, UITabBarDelegate {
		var tabBarItemConstructor: ((ItemIdentifier) -> TabBarItemInstance)?
		var allItems: [ItemIdentifier: TabBarItemInstance] = [:]
		
		override var inUse: Bool { return true }
		
		func identifier(for tabBarItem: UITabBarItem) -> ItemIdentifier? {
			return allItems.first(where: { pair -> Bool in
				pair.value.tabBarItemInstance === tabBarItem
			})?.key
		}
		func tabBarItem(for identifier: ItemIdentifier) -> UITabBarItem? {
			if let existing = allItems[identifier] {
				return existing.tabBarItemInstance
			}
			if let constructor = tabBarItemConstructor {
				let new = constructor(identifier)
				allItems[identifier] = new
				return new.tabBarItemInstance
			}
			return nil
		}
	}
	
	class Delegate: DynamicDelegate, UITabBarDelegate {
		required override init() {
			super.init()
		}

		var didSelectIndex: SignalInput<ItemIdentifier>?
		func tabBar(_ tabBar: UITabBar, didSelect item: UITabBarItem) {
			if let identifier = (tabBar.delegate as? Storage)?.identifier(for: item) {
				didSelectIndex?.send(value: identifier)
			}
		}

		var willBeginCustomizing: SignalInput<[ItemIdentifier]>?
		func tabBar(_ tabBar: UITabBar, willBeginCustomizing items: [UITabBarItem]) {
			if let storage = tabBar.delegate as? Storage {
				willBeginCustomizing?.send(value: items.compactMap { storage.identifier(for: $0) })
			}
		}

		var didBeginCustomizing: SignalInput<[ItemIdentifier]>?
		func tabBar(_ tabBar: UITabBar, didBeginCustomizing items: [UITabBarItem]) {
			if let storage = tabBar.delegate as? Storage {
				didBeginCustomizing?.send(value: items.compactMap { storage.identifier(for: $0) })
			}
		}

		var willEndCustomizing: SignalInput<([ItemIdentifier], Bool)>?
		func tabBar(_ tabBar: UITabBar, willEndCustomizing items: [UITabBarItem], changed: Bool) {
			if let storage = tabBar.delegate as? Storage {
				willEndCustomizing?.send(value: (items.compactMap { storage.identifier(for: $0) }, changed))
			}
		}

		var didEndCustomizing: SignalInput<([ItemIdentifier], Bool)>?
		func tabBar(_ tabBar: UITabBar, didEndCustomizing items: [UITabBarItem], changed: Bool) {
			if let storage = tabBar.delegate as? Storage {
				didEndCustomizing?.send(value: (items.compactMap { storage.identifier(for: $0) }, changed))
			}
		}
	}
}

extension BindingName where Binding: TabBarBinding {
	// You can easily convert the `Binding` cases to `BindingName` by copying them to here and using the following Xcode-style regex:
	// Find:    case ([^\(]+)\((.+)\)$
	// Replace: static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.$1(v)) }) }
	static var items: BindingName<DynamicValue<SetOrAnimate<[Binding.ItemIdentifierType]>>, Binding> { return BindingName<DynamicValue<SetOrAnimate<[Binding.ItemIdentifierType]>>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.items(v)) }) }
	static var selectItem: BindingName<Signal<Binding.ItemIdentifierType>, Binding> { return BindingName<Signal<Binding.ItemIdentifierType>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.selectItem(v)) }) }
	static var barStyle: BindingName<DynamicValue<UIBarStyle>, Binding> { return BindingName<DynamicValue<UIBarStyle>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.barStyle(v)) }) }
	static var isTranslucent: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.isTranslucent(v)) }) }
	static var barTintColor: BindingName<DynamicValue<UIColor>, Binding> { return BindingName<DynamicValue<UIColor>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.barTintColor(v)) }) }
	static var tintColor: BindingName<DynamicValue<UIColor>, Binding> { return BindingName<DynamicValue<UIColor>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.tintColor(v)) }) }
	@available(iOS 10.0, *)
	static var unselectedItemTintColor: BindingName<DynamicValue<UIColor>, Binding> { return BindingName<DynamicValue<UIColor>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.unselectedItemTintColor(v)) }) }
	static var backgroundImage: BindingName<DynamicValue<UIImage?>, Binding> { return BindingName<DynamicValue<UIImage?>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.backgroundImage(v)) }) }
	static var shadowImage: BindingName<DynamicValue<UIImage?>, Binding> { return BindingName<DynamicValue<UIImage?>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.shadowImage(v)) }) }
	static var selectionIndicatorImage: BindingName<DynamicValue<UIImage?>, Binding> { return BindingName<DynamicValue<UIImage?>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.selectionIndicatorImage(v)) }) }
	static var itemPositioning: BindingName<DynamicValue<UITabBarItemPositioning>, Binding> { return BindingName<DynamicValue<UITabBarItemPositioning>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.itemPositioning(v)) }) }
	static var itemSpacing: BindingName<DynamicValue<CGFloat>, Binding> { return BindingName<DynamicValue<CGFloat>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.itemSpacing(v)) }) }
	static var itemWidth: BindingName<DynamicValue<CGFloat>, Binding> { return BindingName<DynamicValue<CGFloat>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.itemWidth(v)) }) }
	static var customizingItems: BindingName<Signal<SetOrAnimate<[Binding.ItemIdentifierType]?>>, Binding> { return BindingName<Signal<SetOrAnimate<[Binding.ItemIdentifierType]?>>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.customizingItems(v)) }) }
	static var willBeginCustomizing: BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding> { return BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.willBeginCustomizing(v)) }) }
	static var didBeginCustomizing: BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding> { return BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.didBeginCustomizing(v)) }) }
	static var willEndCustomizing: BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding> { return BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.willEndCustomizing(v)) }) }
	static var didEndCustomizing: BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding> { return BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.didEndCustomizing(v)) }) }
	static var didSelectItem: BindingName<SignalInput<Binding.ItemIdentifierType>, Binding> { return BindingName<SignalInput<Binding.ItemIdentifierType>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.didSelectItem(v)) }) }
	static var itemConstructor: BindingName<(Binding.ItemIdentifierType) -> TabBarItemInstance, Binding> { return BindingName<(Binding.ItemIdentifierType) -> TabBarItemInstance, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.itemConstructor(v)) }) }
}

protocol TabBarInstance {
	var tabBarInstance: UITabBar { get }
}
extension TabBarInstance {
	var viewInstance: View.Instance { return tabBarInstance }
}
extension TabBar.Instance: TabBarInstance {
	var tabBarInstance: UITabBar { return self }
}

protocol TabBarBinding: ViewBinding {
	associatedtype ItemIdentifierType: Hashable
	static func tabBarBinding(_ binding: TabBar<ItemIdentifierType>.Binding) -> Self
}
extension TabBarBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return Self.tabBarBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlTabBarController.swift ###

#if os(macOS)
	import AppKit
#else
	import UIKit
#endif

class TabBarController<ItemIdentifier: Hashable>: ConstructingBinder, TabBarControllerInstance {
	typealias Instance = UITabBarController
	typealias Inherited = ViewController
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var tabBarControllerInstance: Instance { return instance() }
	
	enum Binding: TabBarControllerBinding {
		typealias ItemIdentifierType = ItemIdentifier
		typealias Binder = TabBarController
		static func tabBarControllerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case tabBar(StaticValue<TabBar<ItemIdentifier>>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case items(DynamicValue<SetOrAnimate<[ItemIdentifier]>>)
		case customizableItems(DynamicValue<Set<ItemIdentifier>>)

		// 2. Signal bindings are performed on the object after construction.
		case selectItem(Signal<ItemIdentifier>)

		// 3. Action bindings are triggered by the object after construction.
		case didSelect(SignalInput<ItemIdentifier>)
		case willBeginCustomizing(SignalInput<[ItemIdentifier]>)
		case willEndCustomizing(SignalInput<([ItemIdentifier], Bool)>)
		case didEndCustomizing(SignalInput<([ItemIdentifier], Bool)>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case tabConstructor((ItemIdentifier) -> ViewControllerInstance)
		case shouldSelect((ItemIdentifier) -> Bool)
		case supportedInterfaceOrientations(() -> UIInterfaceOrientationMask)
		case preferredInterfaceOrientationForPresentation(() -> UIInterfaceOrientation)
		case interactionControllerForAnimation((UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?)
		case animationControllerForTransition((UIViewController, UIViewController) -> UIViewControllerAnimatedTransitioning?)
	}

	struct Preparer: ConstructingPreparer {
		typealias Binder = TabBarController
		var linkedPreparer = Inherited.Preparer()

		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }

		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		var tabConstructor: ((ItemIdentifier) -> ViewControllerInstance)?
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .tabConstructor(let x): tabConstructor = x
			case .shouldSelect(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:shouldSelect:))
				delegate().addSelector(s).shouldSelect = x
			case .supportedInterfaceOrientations(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarControllerSupportedInterfaceOrientations(_:))
				delegate().addSelector(s).supportedInterfaceOrientations = x
			case .preferredInterfaceOrientationForPresentation(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarControllerPreferredInterfaceOrientationForPresentation(_:))
				delegate().addSelector(s).preferredInterfaceOrientationForPresentation = x
			case .interactionControllerForAnimation(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:interactionControllerFor:))
				delegate().addSelector(s).interactionControllerForAnimation = x
			case .animationControllerForTransition(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:animationControllerForTransitionFrom:to:))
				delegate().addSelector(s).animationControllerForTransition = x
			case .willBeginCustomizing(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:willBeginCustomizing:))
				delegate().addSelector(s).willBeginCustomizing = x
			case .willEndCustomizing(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:willEndCustomizing:changed:))
				delegate().addSelector(s).willEndCustomizing = x
			case .didEndCustomizing(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:didEndCustomizing:changed:))
				delegate().addSelector(s).didEndCustomizing = x
			case .didSelect(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:didSelect:))
				delegate().addSelector(s).didSelect = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")

			storage.dynamicDelegate = possibleDelegate
			storage.tabConstructor = tabConstructor

			if storage.inUse {
				instance.delegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .tabBar(let x):
				x.value.applyBindings(to: instance.tabBar)
				return nil
			case .items(let x):
				return x.apply(instance, storage) { inst, stor, val in
					let items = val.value.compactMap { stor.viewController(for: $0) }
					inst.setViewControllers(items, animated: val.isAnimated)
				}
			case .customizableItems(let x):
				return x.apply(instance, storage) { inst, stor, val in
					inst.customizableViewControllers = val.compactMap { stor.viewController(for: $0) }
				}
			case .selectItem(let x):
				return x.apply(instance, storage) { inst, stor, val in
					if let vc = stor.viewController(for: val), let index = inst.viewControllers?.index(of: vc) {
						inst.selectedIndex = index
					}
				}
			case .tabConstructor: return nil
			case .didSelect: return nil
			case .willBeginCustomizing: return nil
			case .willEndCustomizing: return nil
			case .didEndCustomizing: return nil
			case .shouldSelect: return nil
			case .supportedInterfaceOrientations: return nil
			case .preferredInterfaceOrientationForPresentation: return nil
			case .interactionControllerForAnimation: return nil
			case .animationControllerForTransition: return nil
			case .inheritedBinding(let b): return linkedPreparer.applyBinding(b, instance: instance, storage: storage)
			}
		}
	}

	class Storage: ViewController.Storage, UITabBarControllerDelegate {
		var tabConstructor: ((ItemIdentifier) -> ViewControllerInstance)?
		var allItems: [ItemIdentifier: ViewControllerInstance] = [:]
		
		override var inUse: Bool { return true }
		
		func identifier(for viewController: UIViewController) -> ItemIdentifier? {
			return allItems.first(where: { pair -> Bool in
				pair.value.viewControllerInstance === viewController
			})?.key
		}
		func viewController(for identifier: ItemIdentifier) -> UIViewController? {
			if let existing = allItems[identifier] {
				return existing.viewControllerInstance
			}
			if let constructor = tabConstructor {
				let new = constructor(identifier)
				allItems[identifier] = new
				return new.viewControllerInstance
			}
			return nil
		}
	}
	
	class Delegate: DynamicDelegate, UITabBarControllerDelegate {
		required override init() {
			super.init()
		}

		var didSelect: SignalInput<ItemIdentifier>?
		func tabBarController(_ tabBarController: UITabBarController, didSelect viewController: UIViewController) {
			if let identifier = (tabBarController.delegate as? Storage)?.identifier(for: viewController) {
				didSelect?.send(value: identifier)
			}
		}

		var willBeginCustomizing: SignalInput<[ItemIdentifier]>?
		func tabBarController(_ tabBarController: UITabBarController, willBeginCustomizing viewControllers: [UIViewController]) {
			if let storage = tabBarController.delegate as? Storage {
				willBeginCustomizing?.send(value: viewControllers.compactMap { storage.identifier(for: $0) })
			}
		}

		var didBeginCustomizing: SignalInput<[ItemIdentifier]>?
		func tabBarController(_ tabBarController: UITabBarController, didBeginCustomizing viewControllers: [UIViewController]) {
			if let storage = tabBarController.delegate as? Storage {
				didBeginCustomizing?.send(value: viewControllers.compactMap { storage.identifier(for: $0) })
			}
		}

		var willEndCustomizing: SignalInput<([ItemIdentifier], Bool)>?
		func tabBarController(_ tabBarController: UITabBarController, willEndCustomizing viewControllers: [UIViewController], changed: Bool) {
			if let storage = tabBarController.delegate as? Storage {
				willEndCustomizing?.send(value: (viewControllers.compactMap { storage.identifier(for: $0) }, changed))
			}
		}

		var didEndCustomizing: SignalInput<([ItemIdentifier], Bool)>?
		func tabBarController(_ tabBarController: UITabBarController, didEndCustomizing viewControllers: [UIViewController], changed: Bool) {
			if let storage = tabBarController.delegate as? Storage {
				didEndCustomizing?.send(value: (viewControllers.compactMap { storage.identifier(for: $0) }, changed))
			}
		}
		
		var shouldSelect: ((ItemIdentifier) -> Bool)?
		func tabBarController(_ tabBarController: UITabBarController, shouldSelect viewController: UIViewController) -> Bool {
			if let storage = tabBarController.delegate as? Storage, let identifier = storage.identifier(for: viewController) {
				return shouldSelect!(identifier)
			}
			return false
		}
		
		var supportedInterfaceOrientations: (() -> UIInterfaceOrientationMask)?
		func tabBarControllerSupportedInterfaceOrientations(_ tabBarController: UITabBarController) -> UIInterfaceOrientationMask {
			return supportedInterfaceOrientations!()
		}
		
		var preferredInterfaceOrientationForPresentation: (() -> UIInterfaceOrientation)?
		func tabBarControllerPreferredInterfaceOrientationForPresentation(_ tabBarController: UITabBarController) -> UIInterfaceOrientation {
			return preferredInterfaceOrientationForPresentation!()
		}
		
		var interactionControllerForAnimation: ((UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?)?
		func tabBarController(_ tabBarController: UITabBarController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
			return interactionControllerForAnimation!(animationController)
		}
		
		var animationControllerForTransition: ((UIViewController, UIViewController) -> UIViewControllerAnimatedTransitioning?)?
		func tabBarController(_ tabBarController: UITabBarController, animationControllerForTransitionFrom fromVC: UIViewController, to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
			return animationControllerForTransition!(fromVC, toVC)
		}
	}
}

extension BindingName where Binding: TabBarControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` by copying them to here and using the following Xcode-style regex:
	// Find:    case ([^\(]+)\((.+)\)$
	// Replace: static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.$1(v)) }) }
	static var tabBar: BindingName<StaticValue<TabBar<Binding.ItemIdentifierType>>, Binding> { return BindingName<StaticValue<TabBar<Binding.ItemIdentifierType>>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.tabBar(v)) }) }
	static var items: BindingName<DynamicValue<SetOrAnimate<[Binding.ItemIdentifierType]>>, Binding> { return BindingName<DynamicValue<SetOrAnimate<[Binding.ItemIdentifierType]>>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.items(v)) }) }
	static var customizableItems: BindingName<DynamicValue<Set<Binding.ItemIdentifierType>>, Binding> { return BindingName<DynamicValue<Set<Binding.ItemIdentifierType>>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.customizableItems(v)) }) }
	static var selectItem: BindingName<Signal<Binding.ItemIdentifierType>, Binding> { return BindingName<Signal<Binding.ItemIdentifierType>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.selectItem(v)) }) }
	static var didSelect: BindingName<SignalInput<Binding.ItemIdentifierType>, Binding> { return BindingName<SignalInput<Binding.ItemIdentifierType>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.didSelect(v)) }) }
	static var willBeginCustomizing: BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding> { return BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.willBeginCustomizing(v)) }) }
	static var willEndCustomizing: BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding> { return BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.willEndCustomizing(v)) }) }
	static var didEndCustomizing: BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding> { return BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.didEndCustomizing(v)) }) }
	static var tabConstructor: BindingName<(Binding.ItemIdentifierType) -> ViewControllerInstance, Binding> { return BindingName<(Binding.ItemIdentifierType) -> ViewControllerInstance, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.tabConstructor(v)) }) }
	static var shouldSelect: BindingName<(Binding.ItemIdentifierType) -> Bool, Binding> { return BindingName<(Binding.ItemIdentifierType) -> Bool, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.shouldSelect(v)) }) }
	static var supportedInterfaceOrientations: BindingName<() -> UIInterfaceOrientationMask, Binding> { return BindingName<() -> UIInterfaceOrientationMask, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.supportedInterfaceOrientations(v)) }) }
	static var preferredInterfaceOrientationForPresentation: BindingName<() -> UIInterfaceOrientation, Binding> { return BindingName<() -> UIInterfaceOrientation, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.preferredInterfaceOrientationForPresentation(v)) }) }
	static var interactionControllerForAnimation: BindingName<(UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?, Binding> { return BindingName<(UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.interactionControllerForAnimation(v)) }) }
	static var animationControllerForTransition: BindingName<(UIViewController, UIViewController) -> UIViewControllerAnimatedTransitioning?, Binding> { return BindingName<(UIViewController, UIViewController) -> UIViewControllerAnimatedTransitioning?, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.animationControllerForTransition(v)) }) }
}

protocol TabBarControllerInstance {
	var tabBarControllerInstance: UITabBarController { get }
}
extension TabBarControllerInstance {
	var viewControllerInstance: ViewController.Instance { return tabBarControllerInstance }
}
extension TabBarController.Instance: TabBarControllerInstance {
	var tabBarControllerInstance: UITabBarController { return self }
}

protocol TabBarControllerBinding: ViewControllerBinding {
	associatedtype ItemIdentifierType: Hashable
	static func tabBarControllerBinding(_ binding: TabBarController<ItemIdentifierType>.Binding) -> Self
}
extension TabBarControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return Self.tabBarControllerBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlImageView.swift ###

class ImageView: ConstructingBinder, ImageViewInstance {
	typealias Instance = UIImageView
	typealias Inherited = View
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var imageViewInstance: Instance { return instance() }
	
	enum Binding: ImageViewBinding {
		typealias Binder = ImageView
		static func imageViewBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case image(DynamicValue<UIImage?>)
		case highlightedImage(DynamicValue<UIImage?>)
		case animationImages(DynamicValue<[UIImage]?>)
		case highlightedAnimationImages(DynamicValue<[UIImage]?>)
		case animationDuration(DynamicValue<TimeInterval>)
		case animationRepeatCount(DynamicValue<Int>)
		case isHighlighted(DynamicValue<Bool>)
		
		// 2. Signal bindings are performed on the object after construction.
		case animating(Signal<Bool>)
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = ImageView
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance {
			return subclass.init(image: initialImage ?? nil, highlightedImage: initialHighlightedImage ?? nil)
		}
		
		var image = Captured<UIImage?>()
		var initialImage: UIImage?? = nil
		var highlightedImage = Captured<UIImage?>()
		var initialHighlightedImage: UIImage?? = nil
		
		init() {}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .image(let x):
				image = x.capture()
				initialImage = image.initial()
			case .highlightedImage(let x):
				highlightedImage = x.capture()
				initialHighlightedImage = highlightedImage.initial()
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .image: return image.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.image = v } }
			case .highlightedImage: return highlightedImage.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.highlightedImage = v } }
			case .animationImages(let x): return x.apply(instance, storage) { i, s, v in i.animationImages = v }
			case .highlightedAnimationImages(let x): return x.apply(instance, storage) { i, s, v in i.highlightedAnimationImages = v }
			case .animationDuration(let x): return x.apply(instance, storage) { i, s, v in i.animationDuration = v }
			case .animationRepeatCount(let x): return x.apply(instance, storage) { i, s, v in i.animationRepeatCount = v }
			case .isHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.isHighlighted = v }
			case .animating(let x):
				return x.apply(instance, storage) { i, s, v in
					if v && !i.isAnimating {
						i.startAnimating()
					} else if !v && i.isAnimating {
						i.stopAnimating()
					}
				}
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = View.Storage
}

extension BindingName where Binding: ImageViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .imageViewBinding(ImageView.Binding.$1(v)) }) }
	static var image: BindingName<DynamicValue<UIImage?>, Binding> { return BindingName<DynamicValue<UIImage?>, Binding>({ v in .imageViewBinding(ImageView.Binding.image(v)) }) }
	static var highlightedImage: BindingName<DynamicValue<UIImage?>, Binding> { return BindingName<DynamicValue<UIImage?>, Binding>({ v in .imageViewBinding(ImageView.Binding.highlightedImage(v)) }) }
	static var animationImages: BindingName<DynamicValue<[UIImage]?>, Binding> { return BindingName<DynamicValue<[UIImage]?>, Binding>({ v in .imageViewBinding(ImageView.Binding.animationImages(v)) }) }
	static var highlightedAnimationImages: BindingName<DynamicValue<[UIImage]?>, Binding> { return BindingName<DynamicValue<[UIImage]?>, Binding>({ v in .imageViewBinding(ImageView.Binding.highlightedAnimationImages(v)) }) }
	static var animationDuration: BindingName<DynamicValue<TimeInterval>, Binding> { return BindingName<DynamicValue<TimeInterval>, Binding>({ v in .imageViewBinding(ImageView.Binding.animationDuration(v)) }) }
	static var animationRepeatCount: BindingName<DynamicValue<Int>, Binding> { return BindingName<DynamicValue<Int>, Binding>({ v in .imageViewBinding(ImageView.Binding.animationRepeatCount(v)) }) }
	static var isHighlighted: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .imageViewBinding(ImageView.Binding.isHighlighted(v)) }) }
	static var animating: BindingName<Signal<Bool>, Binding> { return BindingName<Signal<Bool>, Binding>({ v in .imageViewBinding(ImageView.Binding.animating(v)) }) }
}

protocol ImageViewInstance: ViewInstance {
	var imageViewInstance: ImageView.Instance { get }
}
extension ImageViewInstance {
	var viewInstance: View.Instance { return imageViewInstance }
}
extension ImageView.Instance: ImageViewInstance {
	var imageViewInstance: ImageView.Instance { return self }
}

protocol ImageViewBinding: ViewBinding {
	static func imageViewBinding(_ binding: ImageView.Binding) -> Self
}

extension ImageViewBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return Self.imageViewBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlAlertController.swift ###

class AlertController: ConstructingBinder, AlertControllerInstance {
	typealias Instance = UIAlertController
	typealias Inherited = ViewController
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var alertControllerInstance: Instance { return instance() }
	
	enum Binding: AlertControllerBinding {
		typealias Binder = AlertController
		static func alertControllerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case preferredStyle(StaticValue<UIAlertControllerStyle>)
		case textFields(StaticValue<[TextField]>)
		case actions(StaticValue<[AlertActionInstance]>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case message(DynamicValue<String?>)
		case preferredActionIndex(DynamicValue<Int?>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = AlertController
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance {
			return subclass.init(title: initialTitle, message: initialMessage ?? nil, preferredStyle: preferredStyle)
		}
		
		var title = Captured<String>()
		var initialTitle: String? = nil
		var message = Captured<String?>()
		var initialMessage: String?? = nil
		var preferredStyle: UIAlertControllerStyle = .alert
		
		init() {}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .preferredStyle(let x): preferredStyle = x.value
			case .message(let x):
				message = x.capture()
				initialMessage = message.initial()
			case .inheritedBinding(.title(let x)):
				title = x.capture()
				initialTitle = title.initial()
			case .inheritedBinding(let s): return linkedPreparer.prepareBinding(s)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .preferredStyle: return nil
			case .actions(let x):
				for a in x.value {
					instance.addAction(a.alertActionInstance)
				}
				return nil
			case .textFields(let x):
				for bindings in x.value {
					instance.addTextField { textField in
						bindings.applyBindings(to: textField)
					}
				}
				return nil
			case .message(let x): return x.apply(instance, storage) { i, s, v in i.message = v }
			case .preferredActionIndex(let x):
				return x.apply(instance, storage) { i, s, v in
					i.preferredAction = v.map { i.actions[$0] }
				}
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = ViewController.Storage
}

extension BindingName where Binding: AlertControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .alertControllerBinding(AlertController.Binding.$1(v)) }) }
	static var preferredStyle: BindingName<StaticValue<UIAlertControllerStyle>, Binding> { return BindingName<StaticValue<UIAlertControllerStyle>, Binding>({ v in .alertControllerBinding(AlertController.Binding.preferredStyle(v)) }) }
	static var textFields: BindingName<StaticValue<[TextField]>, Binding> { return BindingName<StaticValue<[TextField]>, Binding>({ v in .alertControllerBinding(AlertController.Binding.textFields(v)) }) }
	static var actions: BindingName<StaticValue<[AlertActionInstance]>, Binding> { return BindingName<StaticValue<[AlertActionInstance]>, Binding>({ v in .alertControllerBinding(AlertController.Binding.actions(v)) }) }
	static var message: BindingName<DynamicValue<String?>, Binding> { return BindingName<DynamicValue<String?>, Binding>({ v in .alertControllerBinding(AlertController.Binding.message(v)) }) }
	static var preferredActionIndex: BindingName<DynamicValue<Int?>, Binding> { return BindingName<DynamicValue<Int?>, Binding>({ v in .alertControllerBinding(AlertController.Binding.preferredActionIndex(v)) }) }
}

protocol AlertControllerInstance: ViewControllerInstance {
	var alertControllerInstance: AlertController.Instance { get }
}
extension AlertControllerInstance {
	var viewControllerInstance: ViewController.Instance { return alertControllerInstance }
}
extension AlertController.Instance: AlertControllerInstance {
	var alertControllerInstance: AlertController.Instance { return self }
}

protocol AlertControllerBinding: ViewControllerBinding {
	static func alertControllerBinding(_ binding: AlertController.Binding) -> Self
}
extension AlertControllerBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return Self.alertControllerBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlTableViewCell.swift ###

class TableViewCell: DerivedBinder, TableViewCellInstance {
	typealias Instance = UITableViewCell
	typealias Inherited = View
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	convenience init(subclass: Instance.Type = Instance.self, _ bindings: Binding...) {
		self.init(subclass: subclass, bindings: bindings)
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	func consumeBindings() -> [Binding] {
		return state.consume().bindings
	}
	func applyBindings(to instance: Instance) {
		state.apply(instance: instance) { i, parameters in
			_ = Preparer.construct(bindings: parameters.bindings, additional: nil, storageConstructor: { $0.constructStorage() }, instanceConstructor: { _ in i })
		}
	}
	func construct(reuseIdentifier: String?, additional: ((Instance) -> Cancellable?)? = nil) -> UITableViewCell {
		return state.construct { parameters in
			Preparer.construct(bindings: parameters.bindings, additional: nil, storageConstructor: { $0.constructStorage() }, instanceConstructor: { $0.constructInstance(reuseIdentifier: reuseIdentifier, subclass: parameters.subclass) })
		}
	}
	func tableViewCellInstance(reuseIdentifier: String?) -> UITableViewCell {
		return construct(reuseIdentifier: reuseIdentifier)
	}
	
	enum Binding: TableViewCellBinding {
		typealias Binder = TableViewCell
		static func tableViewCellBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case cellStyle(StaticValue<UITableViewCellStyle>)
		case textLabel(StaticValue<Label>)
		case detailLabel(StaticValue<Label>)
		case imageView(StaticValue<ImageView>)
		case contentView(StaticValue<View>)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case backgroundView(DynamicValue<ViewInstance?>)
		case selectedBackgroundView(DynamicValue<ViewInstance?>)
		case multipleSelectionBackgroundView(DynamicValue<ViewInstance?>)
		case accessoryType(DynamicValue<UITableViewCellAccessoryType>)
		case accessoryView(DynamicValue<ViewInstance>)
		case editingAccessoryType(DynamicValue<UITableViewCellAccessoryType>)
		case editingAccessoryView(DynamicValue<ViewInstance>)
		case isSelected(DynamicValue<SetOrAnimate<Bool>>)
		case isHighlighted(DynamicValue<SetOrAnimate<Bool>>)
		case isEditing(DynamicValue<SetOrAnimate<Bool>>)
		case showsReorderControl(DynamicValue<Bool>)
		case indentationLevel(DynamicValue<Int>)
		case indentationWidth(DynamicValue<CGFloat>)
		case shouldIndentWhileEditing(DynamicValue<Bool>)
		case separatorInset(DynamicValue<UIEdgeInsets>)
		case focusStyle(DynamicValue<UITableViewCellFocusStyle>)
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = TableViewCell
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init(style: cellStyle, reuseIdentifier: nil) }
		func constructInstance(reuseIdentifier: String?, subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init(style: cellStyle, reuseIdentifier: reuseIdentifier) }
		
		init() {}
		
		var cellStyle: UITableViewCellStyle = .default
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .cellStyle(let x): cellStyle = x.value
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .cellStyle: return nil
			case .textLabel(let x):
				if let l = instance.textLabel {
					x.value.applyBindings(to: l)
				}
				return nil
			case .detailLabel(let x):
				if let l = instance.detailTextLabel {
					x.value.applyBindings(to: l)
				}
				return nil
			case .imageView(let x):
				if let l = instance.imageView {
					x.value.applyBindings(to: l)
				}
				return nil
			case .contentView(let x):
				x.value.applyBindings(to: instance.contentView)
				return nil
			case .backgroundView(let x): return x.apply(instance, storage) { i, s, v in i.backgroundView = v?.viewInstance }
			case .selectedBackgroundView(let x): return x.apply(instance, storage) { i, s, v in i.selectedBackgroundView = v?.viewInstance }
			case .multipleSelectionBackgroundView(let x): return x.apply(instance, storage) { i, s, v in i.multipleSelectionBackgroundView = v?.viewInstance }
			case .accessoryType(let x): return x.apply(instance, storage) { i, s, v in i.accessoryType = v }
			case .accessoryView(let x): return x.apply(instance, storage) { i, s, v in i.accessoryView = v.viewInstance }
			case .editingAccessoryType(let x): return x.apply(instance, storage) { i, s, v in i.editingAccessoryType = v }
			case .editingAccessoryView(let x): return x.apply(instance, storage) { i, s, v in i.editingAccessoryView = v.viewInstance }
			case .isSelected(let x): return x.apply(instance, storage) { i, s, v in i.setSelected(v.value, animated: v.isAnimated) }
			case .isHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.setHighlighted(v.value, animated: v.isAnimated) }
			case .isEditing(let x): return x.apply(instance, storage) { i, s, v in i.setEditing(v.value, animated: v.isAnimated) }
			case .showsReorderControl(let x): return x.apply(instance, storage) { i, s, v in i.showsReorderControl = v }
			case .indentationLevel(let x): return x.apply(instance, storage) { i, s, v in i.indentationLevel = v }
			case .indentationWidth(let x): return x.apply(instance, storage) { i, s, v in i.indentationWidth = v }
			case .shouldIndentWhileEditing(let x): return x.apply(instance, storage) { i, s, v in i.shouldIndentWhileEditing = v }
			case .separatorInset(let x): return x.apply(instance, storage) { i, s, v in i.separatorInset = v }
			case .focusStyle(let x): return x.apply(instance, storage) { i, s, v in i.focusStyle = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = View.Storage
}

extension BindingName where Binding: TableViewCellBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.$1(v)) }) }
	static var cellStyle: BindingName<StaticValue<UITableViewCellStyle>, Binding> { return BindingName<StaticValue<UITableViewCellStyle>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.cellStyle(v)) }) }
	static var textLabel: BindingName<StaticValue<Label>, Binding> { return BindingName<StaticValue<Label>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.textLabel(v)) }) }
	static var detailLabel: BindingName<StaticValue<Label>, Binding> { return BindingName<StaticValue<Label>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.detailLabel(v)) }) }
	static var imageView: BindingName<StaticValue<ImageView>, Binding> { return BindingName<StaticValue<ImageView>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.imageView(v)) }) }
	static var contentView: BindingName<StaticValue<View>, Binding> { return BindingName<StaticValue<View>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.contentView(v)) }) }
	static var backgroundView: BindingName<DynamicValue<ViewInstance?>, Binding> { return BindingName<DynamicValue<ViewInstance?>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.backgroundView(v)) }) }
	static var selectedBackgroundView: BindingName<DynamicValue<ViewInstance?>, Binding> { return BindingName<DynamicValue<ViewInstance?>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.selectedBackgroundView(v)) }) }
	static var multipleSelectionBackgroundView: BindingName<DynamicValue<ViewInstance?>, Binding> { return BindingName<DynamicValue<ViewInstance?>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.multipleSelectionBackgroundView(v)) }) }
	static var accessoryType: BindingName<DynamicValue<UITableViewCellAccessoryType>, Binding> { return BindingName<DynamicValue<UITableViewCellAccessoryType>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.accessoryType(v)) }) }
	static var accessoryView: BindingName<DynamicValue<ViewInstance>, Binding> { return BindingName<DynamicValue<ViewInstance>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.accessoryView(v)) }) }
	static var editingAccessoryType: BindingName<DynamicValue<UITableViewCellAccessoryType>, Binding> { return BindingName<DynamicValue<UITableViewCellAccessoryType>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.editingAccessoryType(v)) }) }
	static var editingAccessoryView: BindingName<DynamicValue<ViewInstance>, Binding> { return BindingName<DynamicValue<ViewInstance>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.editingAccessoryView(v)) }) }
	static var isSelected: BindingName<DynamicValue<SetOrAnimate<Bool>>, Binding> { return BindingName<DynamicValue<SetOrAnimate<Bool>>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.isSelected(v)) }) }
	static var isHighlighted: BindingName<DynamicValue<SetOrAnimate<Bool>>, Binding> { return BindingName<DynamicValue<SetOrAnimate<Bool>>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.isHighlighted(v)) }) }
	static var isEditing: BindingName<DynamicValue<SetOrAnimate<Bool>>, Binding> { return BindingName<DynamicValue<SetOrAnimate<Bool>>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.isEditing(v)) }) }
	static var showsReorderControl: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.showsReorderControl(v)) }) }
	static var indentationLevel: BindingName<DynamicValue<Int>, Binding> { return BindingName<DynamicValue<Int>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.indentationLevel(v)) }) }
	static var indentationWidth: BindingName<DynamicValue<CGFloat>, Binding> { return BindingName<DynamicValue<CGFloat>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.indentationWidth(v)) }) }
	static var shouldIndentWhileEditing: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.shouldIndentWhileEditing(v)) }) }
	static var separatorInset: BindingName<DynamicValue<UIEdgeInsets>, Binding> { return BindingName<DynamicValue<UIEdgeInsets>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.separatorInset(v)) }) }
	static var focusStyle: BindingName<DynamicValue<UITableViewCellFocusStyle>, Binding> { return BindingName<DynamicValue<UITableViewCellFocusStyle>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.focusStyle(v)) }) }
}

protocol TableViewCellInstance: ViewInstance {
	func tableViewCellInstance(reuseIdentifier: String?) -> UITableViewCell
}
extension TableViewCellInstance {
	var viewInstance: UIView { return tableViewCellInstance(reuseIdentifier: nil) }
}
extension UITableViewCell: TableViewCellInstance {
	func tableViewCellInstance(reuseIdentifier: String?) -> UITableViewCell {
		return self
	}
}

protocol TableViewCellBinding: ViewBinding {
	static func tableViewCellBinding(_ binding: TableViewCell.Binding) -> Self
}
extension TableViewCellBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return Self.tableViewCellBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlTabBarItem.swift ###

class TabBarItem: ConstructingBinder, TabBarItemInstance {
	typealias Instance = UITabBarItem
	typealias Inherited = BarItem
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var tabBarItemInstance: Instance { return instance() }
	
	enum Binding: TabBarItemBinding {
		typealias Binder = TabBarItem
		static func tabBarItemBinding(_ binding: Binding) -> Binding { return binding }
		var inheritedInstance: Inherited.Binding? { if case .inheritedBinding(let s) = self { return s } else { return nil } }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case systemItem(StaticValue<UITabBarSystemItem?>)

		//	1. Value bindings may be applied at construction and may subsequently change.
		case selectedImage(DynamicValue<UIImage?>)
		case titlePositionAdjustment(DynamicValue<UIOffset>)
		case badgeValue(DynamicValue<String?>)
		@available(iOS 10.0, *)
		case badgeColor(DynamicValue<UIColor?>)
		@available(iOS 10.0, *)
		case badgeTextAttributes(DynamicValue<ScopedValues<UIControlState, [String : Any]?>>)
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = TabBarItem
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance {
			let x: UITabBarItem
			if let si = systemItem {
				x = subclass.init(tabBarSystemItem: si, tag: tagInitial ?? 0)
			} else if let si = selectedImageInitial {
				x = subclass.init(title: titleInitial ?? nil, image: imageInitial ?? nil, selectedImage: si)
			} else {
				x = subclass.init(title: titleInitial ?? nil, image: imageInitial ?? nil, tag: tagInitial ?? 0)
			}
			return x
		}
		
		var systemItem: UITabBarSystemItem?
		var title = Captured<String>()
		var titleInitial: String? = nil
		var image = Captured<UIImage?>()
		var imageInitial: UIImage?? = nil
		var selectedImage = Captured<UIImage?>()
		var selectedImageInitial: UIImage?? = nil
		var tag = Captured<Int>()
		var tagInitial: Int? = nil
		
		init() {}
		
		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .systemItem(let x): systemItem = x.value
			case .selectedImage(let x):
				selectedImage = x.capture()
				selectedImageInitial = selectedImage.initial()
			case .inheritedBinding(.tag(let x)):
				tag = x.capture()
				tagInitial = tag.initial()
			case .inheritedBinding(.image(let x)):
				image = x.capture()
				imageInitial = image.initial()
			case .inheritedBinding(.title(let x)):
				title = x.capture()
				titleInitial = title.initial()
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .badgeTextAttributes(let x):
				if #available(iOS 10.0, *) {
					var previous: ScopedValues<UIControlState, [String : Any]?>? = nil
					return x.apply(instance, storage) { i, s, v in
						if let p = previous {
							for c in p.pairs {
								i.setBadgeTextAttributes(nil, for: c.0)
							}
						}
						previous = v
						for c in v.pairs {
							i.setBadgeTextAttributes(c.1, for: c.0)
						}
					}
				} else {
					return nil
				}
			case .titlePositionAdjustment(let x): return x.apply(instance, storage) { i, s, v in i.titlePositionAdjustment = v }
			case .badgeValue(let x): return x.apply(instance, storage) { i, s, v in i.badgeValue = v }
			case .badgeColor(let x):
				return x.apply(instance, storage) { i, s, v in
					if #available(iOS 10.0, *) {
						i.badgeColor = v
					}
				}
			case .systemItem: return nil
			case .selectedImage: return selectedImage.resume()?.apply(instance, storage) { i, s, v in i.selectedImage = v }
			case .inheritedBinding(.tag): return tag.resume()?.apply(instance, storage) { i, s, v in i.tag = v }
			case .inheritedBinding(.image): return image.resume()?.apply(instance, storage) { i, s, v in i.image = v }
			case .inheritedBinding(.title): return title.resume()?.apply(instance, storage) { i, s, v in i.title = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = BarItem.Storage
}

extension BindingName where Binding: TabBarItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.$1(v)) }) }
	static var selectedImage: BindingName<DynamicValue<UIImage?>, Binding> { return BindingName<DynamicValue<UIImage?>, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.selectedImage(v)) }) }
	static var titlePositionAdjustment: BindingName<DynamicValue<UIOffset>, Binding> { return BindingName<DynamicValue<UIOffset>, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.titlePositionAdjustment(v)) }) }
	static var badgeValue: BindingName<DynamicValue<String?>, Binding> { return BindingName<DynamicValue<String?>, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.badgeValue(v)) }) }
	@available(iOS 10.0, *)
	static var badgeColor: BindingName<DynamicValue<UIColor?>, Binding> { return BindingName<DynamicValue<UIColor?>, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.badgeColor(v)) }) }
	@available(iOS 10.0, *)
	static var badgeTextAttributes: BindingName<DynamicValue<ScopedValues<UIControlState, [String : Any]?>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIControlState, [String : Any]?>>, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.badgeTextAttributes(v)) }) }
}

protocol TabBarItemInstance: BarItemInstance {
	var tabBarItemInstance: TabBarItem.Instance { get }
}
extension TabBarItemInstance {
	var barItemInstance: BarItem.Instance { return tabBarItemInstance }
}
extension TabBarItem.Instance: TabBarItemInstance {
	var tabBarItemInstance: TabBarItem.Instance { return self }
}

protocol TabBarItemBinding: BarItemBinding {
	static func tabBarItemBinding(_ binding: TabBarItem.Binding) -> Self
}
extension TabBarItemBinding {
	static func barItemBinding(_ binding: BarItem.Binding) -> Self {
		return Self.tabBarItemBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlLongPressGestureRecognizer.swift ###

class LongPressGestureRecognizer: ConstructingBinder, LongPressGestureRecognizerInstance {
	typealias Instance = UILongPressGestureRecognizer
	typealias Inherited = GestureRecognizer
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var longPressGestureRecognizerInstance: Instance { return instance() }
	
	enum Binding: LongPressGestureRecognizerBinding {
		typealias Binder = LongPressGestureRecognizer
		static func longPressGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case minimumPressDuration(DynamicValue<CFTimeInterval>)
		case numberOfTouchesRequired(DynamicValue<Int>)
		case numberOfTapsRequired(DynamicValue<Int>)
		case allowableMovement(DynamicValue<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = LongPressGestureRecognizer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .minimumPressDuration(let x): return x.apply(instance, storage) { i, s, v in i.minimumPressDuration = v }
			case .numberOfTouchesRequired(let x): return x.apply(instance, storage) { i, s, v in i.numberOfTouchesRequired = v }
			case .numberOfTapsRequired(let x): return x.apply(instance, storage) { i, s, v in i.numberOfTapsRequired = v }
			case .allowableMovement(let x): return x.apply(instance, storage) { i, s, v in i.allowableMovement = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: LongPressGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .longPressGestureRecognizerBinding(LongPressGestureRecognizer.Binding.$1(v)) }) }
	static var minimumPressDuration: BindingName<DynamicValue<CFTimeInterval>, Binding> { return BindingName<DynamicValue<CFTimeInterval>, Binding>({ v in .longPressGestureRecognizerBinding(LongPressGestureRecognizer.Binding.minimumPressDuration(v)) }) }
	static var numberOfTouchesRequired: BindingName<DynamicValue<Int>, Binding> { return BindingName<DynamicValue<Int>, Binding>({ v in .longPressGestureRecognizerBinding(LongPressGestureRecognizer.Binding.numberOfTouchesRequired(v)) }) }
	static var numberOfTapsRequired: BindingName<DynamicValue<Int>, Binding> { return BindingName<DynamicValue<Int>, Binding>({ v in .longPressGestureRecognizerBinding(LongPressGestureRecognizer.Binding.numberOfTapsRequired(v)) }) }
	static var allowableMovement: BindingName<DynamicValue<CGFloat>, Binding> { return BindingName<DynamicValue<CGFloat>, Binding>({ v in .longPressGestureRecognizerBinding(LongPressGestureRecognizer.Binding.allowableMovement(v)) }) }
}

protocol LongPressGestureRecognizerInstance: GestureRecognizerInstance {
	var longPressGestureRecognizerInstance: LongPressGestureRecognizer.Instance { get }
}
extension LongPressGestureRecognizerInstance {
	var gestureRecognizerInstance: GestureRecognizer.Instance { return longPressGestureRecognizerInstance }
}
extension LongPressGestureRecognizer.Instance: LongPressGestureRecognizerInstance {
	var longPressGestureRecognizerInstance: LongPressGestureRecognizer.Instance { return self }
}

protocol LongPressGestureRecognizerBinding: GestureRecognizerBinding {
	static func longPressGestureRecognizerBinding(_ binding: LongPressGestureRecognizer.Binding) -> Self
}

extension LongPressGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return Self.longPressGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlAlertAction.swift ###

class AlertAction: ConstructingBinder, AlertActionInstance {
	typealias Instance = UIAlertAction
	typealias Inherited = BaseBinder
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var alertActionInstance: Instance { return instance() }
	
	enum Binding: AlertActionBinding {
		typealias Binder = AlertAction
		static func alertActionBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case title(StaticValue<String>)
		case style(StaticValue<UIAlertActionStyle>)

		//	1. Value bindings may be applied at construction and may subsequently change.
		case isEnabled(DynamicValue<Bool>)

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.
		case handler(SignalInput<()>)

		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}

	struct Preparer: ConstructingPreparer {
		typealias Binder = AlertAction
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance {
			return subclass.init(title: title, style: style, handler: handler.map { h in
				{ _ in h.send(value: ()) }
			})
		}
		
		var title: String? = nil
		var style: UIAlertActionStyle = .default
		var handler: SignalInput<()>? = nil

		init() {}
		
		mutating func prepareBinding(_ binding: AlertAction.Binding) {
			switch binding {
			case .title(let x): title = x.value
			case .style(let x): style = x.value
			case .handler(let x): handler = x
			case .inheritedBinding(let s): return linkedPreparer.prepareBinding(s)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .title: return nil
			case .style: return nil
			case .handler: return nil
			case .isEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isEnabled = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: (), storage: ())
			}
		}
		
		mutating func finalizeInstance(_ instance: Instance, storage: Storage) -> Cancellable? {
			let linkedCancellable = linkedPreparer.finalizeInstance(instance, storage: storage)
			return ArrayOfCancellables([linkedCancellable, handler as Cancellable?].compactMap { $0 })
		}
	}

	typealias Storage = ObjectBinderStorage
}

extension BindingName where Binding: AlertActionBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .alertActionBinding(AlertAction.Binding.$1(v)) }) }
	static var title: BindingName<StaticValue<String>, Binding> { return BindingName<StaticValue<String>, Binding>({ v in .alertActionBinding(AlertAction.Binding.title(v)) }) }
	static var style: BindingName<StaticValue<UIAlertActionStyle>, Binding> { return BindingName<StaticValue<UIAlertActionStyle>, Binding>({ v in .alertActionBinding(AlertAction.Binding.style(v)) }) }
	static var handler: BindingName<SignalInput<()>, Binding> { return BindingName<SignalInput<()>, Binding>({ v in .alertActionBinding(AlertAction.Binding.handler(v)) }) }
	static var isEnabled: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .alertActionBinding(AlertAction.Binding.isEnabled(v)) }) }
}

protocol AlertActionInstance {
	var alertActionInstance: AlertAction.Instance { get }
}
extension AlertAction.Instance: AlertActionInstance {
	var alertActionInstance: AlertAction.Instance { return self }
}

protocol AlertActionBinding: BaseBinding {
	static func alertActionBinding(_ binding: AlertAction.Binding) -> Self
}
extension AlertActionBinding {
	static func baseBinderBinding(_ binding: BaseBinder.Binding) -> Self {
		return Self.alertActionBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlSlider.swift ###

class Slider: ConstructingBinder, SliderInstance {
	typealias Instance = UISlider
	typealias Inherited = Control
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var sliderInstance: Instance { return instance() }
	
	enum Binding: SliderBinding {
		typealias Binder = Slider
		static func sliderBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case value(DynamicValue<SetOrAnimate<Float>>)
		case maximumValue(DynamicValue<Float>)
		case minimumValue(DynamicValue<Float>)
		case isContinuous(DynamicValue<Bool>)
		case minimumValueImage(DynamicValue<UIImage?>)
		case maximumValueImage(DynamicValue<UIImage?>)
		case minimumTrackTintColor(DynamicValue<UIColor?>)
		case maximumTrackTintColor(DynamicValue<UIColor?>)
		case thumbTintColor(DynamicValue<UIColor?>)
		case thumbImage(DynamicValue<ScopedValues<UIControlState, UIImage?>>)
		case minimumTrackImage(DynamicValue<ScopedValues<UIControlState, UIImage?>>)
		case maximumTrackImage(DynamicValue<ScopedValues<UIControlState, UIImage?>>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = Slider
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .thumbImage(let x):
				var previous: ScopedValues<UIControlState, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setThumbImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setThumbImage(c.1, for: c.0)
					}
				}
			case .minimumTrackImage(let x):
				var previous: ScopedValues<UIControlState, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setMinimumTrackImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setMinimumTrackImage(c.1, for: c.0)
					}
				}
			case .maximumTrackImage(let x):
				var previous: ScopedValues<UIControlState, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setMaximumTrackImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setMaximumTrackImage(c.1, for: c.0)
					}
				}
			case .value(let x): return x.apply(instance, storage) { i, s, v in i.setValue(v.value, animated: v.isAnimated) }
			case .maximumValue(let x): return x.apply(instance, storage) { i, s, v in i.maximumValue = v }
			case .minimumValue(let x): return x.apply(instance, storage) { i, s, v in i.minimumValue = v }
			case .isContinuous(let x): return x.apply(instance, storage) { i, s, v in i.isContinuous = v }
			case .minimumValueImage(let x): return x.apply(instance, storage) { i, s, v in i.minimumValueImage = v }
			case .maximumValueImage(let x): return x.apply(instance, storage) { i, s, v in i.maximumValueImage = v }
			case .minimumTrackTintColor(let x): return x.apply(instance, storage) { i, s, v in i.minimumTrackTintColor = v }
			case .maximumTrackTintColor(let x): return x.apply(instance, storage) { i, s, v in i.maximumTrackTintColor = v }
			case .thumbTintColor(let x): return x.apply(instance, storage) { i, s, v in i.thumbTintColor = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = Control.Storage
}

extension BindingName where Binding: SliderBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .sliderBinding(Slider.Binding.$1(v)) }) }
	static var value: BindingName<DynamicValue<SetOrAnimate<Float>>, Binding> { return BindingName<DynamicValue<SetOrAnimate<Float>>, Binding>({ v in .sliderBinding(Slider.Binding.value(v)) }) }
	static var maximumValue: BindingName<DynamicValue<Float>, Binding> { return BindingName<DynamicValue<Float>, Binding>({ v in .sliderBinding(Slider.Binding.maximumValue(v)) }) }
	static var minimumValue: BindingName<DynamicValue<Float>, Binding> { return BindingName<DynamicValue<Float>, Binding>({ v in .sliderBinding(Slider.Binding.minimumValue(v)) }) }
	static var isContinuous: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .sliderBinding(Slider.Binding.isContinuous(v)) }) }
	static var minimumValueImage: BindingName<DynamicValue<UIImage?>, Binding> { return BindingName<DynamicValue<UIImage?>, Binding>({ v in .sliderBinding(Slider.Binding.minimumValueImage(v)) }) }
	static var maximumValueImage: BindingName<DynamicValue<UIImage?>, Binding> { return BindingName<DynamicValue<UIImage?>, Binding>({ v in .sliderBinding(Slider.Binding.maximumValueImage(v)) }) }
	static var minimumTrackTintColor: BindingName<DynamicValue<UIColor?>, Binding> { return BindingName<DynamicValue<UIColor?>, Binding>({ v in .sliderBinding(Slider.Binding.minimumTrackTintColor(v)) }) }
	static var maximumTrackTintColor: BindingName<DynamicValue<UIColor?>, Binding> { return BindingName<DynamicValue<UIColor?>, Binding>({ v in .sliderBinding(Slider.Binding.maximumTrackTintColor(v)) }) }
	static var thumbTintColor: BindingName<DynamicValue<UIColor?>, Binding> { return BindingName<DynamicValue<UIColor?>, Binding>({ v in .sliderBinding(Slider.Binding.thumbTintColor(v)) }) }
	static var thumbImage: BindingName<DynamicValue<ScopedValues<UIControlState, UIImage?>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIControlState, UIImage?>>, Binding>({ v in .sliderBinding(Slider.Binding.thumbImage(v)) }) }
	static var minimumTrackImage: BindingName<DynamicValue<ScopedValues<UIControlState, UIImage?>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIControlState, UIImage?>>, Binding>({ v in .sliderBinding(Slider.Binding.minimumTrackImage(v)) }) }
	static var maximumTrackImage: BindingName<DynamicValue<ScopedValues<UIControlState, UIImage?>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIControlState, UIImage?>>, Binding>({ v in .sliderBinding(Slider.Binding.maximumTrackImage(v)) }) }
}

protocol SliderInstance: ControlInstance {
	var sliderInstance: Slider.Instance { get }
}
extension SliderInstance {
	var controlInstance: Control.Instance { return sliderInstance }
}
extension Slider.Instance: SliderInstance {
	var sliderInstance: Slider.Instance { return self }
}

protocol SliderBinding: ControlBinding {
	static func sliderBinding(_ binding: Slider.Binding) -> Self
}
extension SliderBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return Self.sliderBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlWindow.swift ###

class Window: ConstructingBinder, WindowInstance {
	typealias Instance = UIWindow
	typealias Inherited = View
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var windowInstance: Instance { return instance() }
	
	enum Binding: WindowBinding {
		typealias Binder = Window
		static func windowBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case rootViewController(DynamicValue<ViewControllerInstance>)
		case windowLevel(DynamicValue<UIWindowLevel>)
		case screen(DynamicValue<UIScreen>)
		case frame(DynamicValue<CGRect>)
		
		// 2. Signal bindings are performed on the object after construction.
		case makeKey(Signal<()>)
		
		// 3. Action bindings are triggered by the object after construction.
		case didBecomeVisible(SignalInput<()>)
		case didBecomeHidden(SignalInput<()>)
		case didBecomeKey(SignalInput<()>)
		case didResignKey(SignalInput<()>)
		case keyboardWillShow(SignalInput<[AnyHashable: Any]?>)
		case keyboardDidShow(SignalInput<[AnyHashable: Any]?>)
		case keyboardWillHide(SignalInput<[AnyHashable: Any]?>)
		case keyboardDidHide(SignalInput<[AnyHashable: Any]?>)
		case keyboardWillChangeFrame(SignalInput<[AnyHashable: Any]?>)
		case keyboardDidChangeFrame(SignalInput<[AnyHashable: Any]?>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = Window
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }
		
		init() {}

		var isHidden: Captured<Bool>? = nil
		
		mutating func prepareBinding(_ binding: Window.Binding) {
			switch binding {
			case .inheritedBinding(.isHidden(let x)): isHidden = x.capture()
			case .inheritedBinding(let s): linkedPreparer.prepareBinding(s)
			default: break
			}
		}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .frame(let x): return x.apply(instance, storage) { i, s, v in i.frame = v }
			case .rootViewController(let x):
				return x.apply(instance, storage) { i, s, v in
					let rootViewController = v.viewControllerInstance
					i.rootViewController = rootViewController
					if rootViewController.restorationIdentifier == nil {
						rootViewController.restorationIdentifier = "cwlviews.root"
					}
				}
			case .windowLevel(let x): return x.apply(instance, storage) { i, s, v in i.windowLevel = v }
			case .screen(let x): return x.apply(instance, storage) { i, s, v in i.screen = v }
			case .makeKey(let x): return x.apply(instance, storage) { i, s, v in i.makeKey() }
			case .didBecomeVisible(let x): return Signal.notifications(name: NSNotification.Name.UIWindowDidBecomeVisible, object: instance).map { notification -> () in }.cancellableBind(to: x)
			case .didBecomeHidden(let x): return Signal.notifications(name: NSNotification.Name.UIWindowDidBecomeHidden, object: instance).map { notification -> () in }.cancellableBind(to: x)
			case .didBecomeKey(let x): return Signal.notifications(name: NSNotification.Name.UIWindowDidBecomeKey, object: instance).map { notification -> () in }.cancellableBind(to: x)
			case .didResignKey(let x): return Signal.notifications(name: NSNotification.Name.UIWindowDidResignKey, object: instance).map { notification -> () in }.cancellableBind(to: x)
			case .keyboardWillShow(let x): return Signal.notifications(name: NSNotification.Name.UIKeyboardWillShow, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .keyboardDidShow(let x): return Signal.notifications(name: NSNotification.Name.UIKeyboardDidShow, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .keyboardWillHide(let x): return Signal.notifications(name: NSNotification.Name.UIKeyboardWillHide, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .keyboardDidHide(let x): return Signal.notifications(name: NSNotification.Name.UIKeyboardDidHide, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .keyboardWillChangeFrame(let x): return Signal.notifications(name: NSNotification.Name.UIKeyboardWillChangeFrame, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .keyboardDidChangeFrame(let x): return Signal.notifications(name: NSNotification.Name.UIKeyboardDidChangeFrame, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .inheritedBinding(.isHidden): return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
		
		mutating func finalizeInstance(_ instance: UIWindow, storage: View.Storage) -> Cancellable? {
			let cancellable = linkedPreparer.finalizeInstance(instance, storage: storage)
			if let h = isHidden?.resume() {
				if let c2 = linkedPreparer.applyBinding(.isHidden(.dynamic(h)), instance: instance, storage: storage) {
					return cancellable.map { c1 in ArrayOfCancellables([c2, c1]) } ?? c2
				}
			}
			return cancellable
		}
	}
	
	typealias Storage = View.Storage
}

extension BindingName where Binding: WindowBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .windowBinding(Window.Binding.$1(v)) }) }
	static var frame: BindingName<DynamicValue<CGRect>, Binding> { return BindingName<DynamicValue<CGRect>, Binding>({ v in .windowBinding(Window.Binding.frame(v)) }) }
	static var rootViewController: BindingName<DynamicValue<ViewControllerInstance>, Binding> { return BindingName<DynamicValue<ViewControllerInstance>, Binding>({ v in .windowBinding(Window.Binding.rootViewController(v)) }) }
	static var windowLevel: BindingName<DynamicValue<UIWindowLevel>, Binding> { return BindingName<DynamicValue<UIWindowLevel>, Binding>({ v in .windowBinding(Window.Binding.windowLevel(v)) }) }
	static var screen: BindingName<DynamicValue<UIScreen>, Binding> { return BindingName<DynamicValue<UIScreen>, Binding>({ v in .windowBinding(Window.Binding.screen(v)) }) }
	static var makeKey: BindingName<Signal<()>, Binding> { return BindingName<Signal<()>, Binding>({ v in .windowBinding(Window.Binding.makeKey(v)) }) }
	static var didBecomeVisible: BindingName<SignalInput<()>, Binding> { return BindingName<SignalInput<()>, Binding>({ v in .windowBinding(Window.Binding.didBecomeVisible(v)) }) }
	static var didBecomeHidden: BindingName<SignalInput<()>, Binding> { return BindingName<SignalInput<()>, Binding>({ v in .windowBinding(Window.Binding.didBecomeHidden(v)) }) }
	static var didBecomeKey: BindingName<SignalInput<()>, Binding> { return BindingName<SignalInput<()>, Binding>({ v in .windowBinding(Window.Binding.didBecomeKey(v)) }) }
	static var didResignKey: BindingName<SignalInput<()>, Binding> { return BindingName<SignalInput<()>, Binding>({ v in .windowBinding(Window.Binding.didResignKey(v)) }) }
	static var keyboardWillShow: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardWillShow(v)) }) }
	static var keyboardDidShow: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardDidShow(v)) }) }
	static var keyboardWillHide: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardWillHide(v)) }) }
	static var keyboardDidHide: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardDidHide(v)) }) }
	static var keyboardWillChangeFrame: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardWillChangeFrame(v)) }) }
	static var keyboardDidChangeFrame: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardDidChangeFrame(v)) }) }
}

protocol WindowInstance: ViewInstance {
	var windowInstance: Window.Instance { get }
}
extension WindowInstance {
	var viewInstance: View.Instance { return windowInstance }
}
extension Window.Instance: WindowInstance {
	var windowInstance: Window.Instance { return self }
}

protocol WindowBinding: ViewBinding {
	static func windowBinding(_ binding: Window.Binding) -> Self
}
extension WindowBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return Self.windowBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlSwitch.swift ###

class Switch: ConstructingBinder, SwitchInstance {
	typealias Instance = UISwitch
	typealias Inherited = Control
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var switchInstance: Instance { return instance() }
	
	enum Binding: SwitchBinding {
		typealias Binder = Switch
		static func switchBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case isOn(DynamicValue<SetOrAnimate<Bool>>)
		case onTintColor(DynamicValue<UIColor>)
		case tintColor(DynamicValue<UIColor>)
		case thumbTintColor(DynamicValue<UIColor>)
		case onImage(DynamicValue<UIImage?>)
		case offImage(DynamicValue<UIImage?>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = Switch
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .isOn(let x): return x.apply(instance, storage) { i, s, v in i.setOn(v.value, animated: v.isAnimated) }
			case .onTintColor(let x): return x.apply(instance, storage) { i, s, v in i.onTintColor = v }
			case .tintColor(let x): return x.apply(instance, storage) { i, s, v in i.tintColor = v }
			case .thumbTintColor(let x): return x.apply(instance, storage) { i, s, v in i.thumbTintColor = v }
			case .onImage(let x): return x.apply(instance, storage) { i, s, v in i.onImage = v }
			case .offImage(let x): return x.apply(instance, storage) { i, s, v in i.offImage = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = Control.Storage
}

extension BindingName where Binding: SwitchBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .switchBinding(Switch.Binding.$1(v)) }) }
	static var isOn: BindingName<DynamicValue<SetOrAnimate<Bool>>, Binding> { return BindingName<DynamicValue<SetOrAnimate<Bool>>, Binding>({ v in .switchBinding(Switch.Binding.isOn(v)) }) }
	static var onTintColor: BindingName<DynamicValue<UIColor>, Binding> { return BindingName<DynamicValue<UIColor>, Binding>({ v in .switchBinding(Switch.Binding.onTintColor(v)) }) }
	static var tintColor: BindingName<DynamicValue<UIColor>, Binding> { return BindingName<DynamicValue<UIColor>, Binding>({ v in .switchBinding(Switch.Binding.tintColor(v)) }) }
	static var thumbTintColor: BindingName<DynamicValue<UIColor>, Binding> { return BindingName<DynamicValue<UIColor>, Binding>({ v in .switchBinding(Switch.Binding.thumbTintColor(v)) }) }
	static var onImage: BindingName<DynamicValue<UIImage?>, Binding> { return BindingName<DynamicValue<UIImage?>, Binding>({ v in .switchBinding(Switch.Binding.onImage(v)) }) }
	static var offImage: BindingName<DynamicValue<UIImage?>, Binding> { return BindingName<DynamicValue<UIImage?>, Binding>({ v in .switchBinding(Switch.Binding.offImage(v)) }) }
}

protocol SwitchInstance: ControlInstance {
	var switchInstance: Switch.Instance { get }
}
extension SwitchInstance {
	var controlInstance: Control.Instance { return switchInstance }
}
extension Switch.Instance: SwitchInstance {
	var switchInstance: Switch.Instance { return self }
}

protocol SwitchBinding: ControlBinding {
	static func switchBinding(_ binding: Switch.Binding) -> Self
}
extension SwitchBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self {
		return Self.switchBinding(.inheritedBinding(binding))
	}
}


// MARK: ### CwlPanGestureRecognizer.swift ###

class PanGestureRecognizer: ConstructingBinder, PanGestureRecognizerInstance {
	typealias Instance = UIPanGestureRecognizer
	typealias Inherited = GestureRecognizer
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var panGestureRecognizerInstance: Instance { return instance() }
	
	enum Binding: PanGestureRecognizerBinding {
		typealias Binder = PanGestureRecognizer
		static func panGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case maximumNumberOfTouches(DynamicValue<Int>)
		case minimumNumberOfTouches(DynamicValue<Int>)
		case translation(DynamicValue<CGPoint>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = PanGestureRecognizer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .maximumNumberOfTouches(let x): return x.apply(instance, storage) { i, s, v in i.maximumNumberOfTouches = v }
			case .minimumNumberOfTouches(let x): return x.apply(instance, storage) { i, s, v in i.minimumNumberOfTouches = v }
			case .translation(let x): return x.apply(instance, storage) { i, s, v in i.setTranslation(v, in: nil) }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: PanGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .panGestureRecognizerBinding(PanGestureRecognizer.Binding.$1(v)) }) }
	static var maximumNumberOfTouches: BindingName<DynamicValue<Int>, Binding> { return BindingName<DynamicValue<Int>, Binding>({ v in .panGestureRecognizerBinding(PanGestureRecognizer.Binding.maximumNumberOfTouches(v)) }) }
	static var minimumNumberOfTouches: BindingName<DynamicValue<Int>, Binding> { return BindingName<DynamicValue<Int>, Binding>({ v in .panGestureRecognizerBinding(PanGestureRecognizer.Binding.minimumNumberOfTouches(v)) }) }
	static var translation: BindingName<DynamicValue<CGPoint>, Binding> { return BindingName<DynamicValue<CGPoint>, Binding>({ v in .panGestureRecognizerBinding(PanGestureRecognizer.Binding.translation(v)) }) }
}

protocol PanGestureRecognizerInstance: GestureRecognizerInstance {
	var panGestureRecognizerInstance: PanGestureRecognizer.Instance { get }
}
extension PanGestureRecognizerInstance {
	var gestureRecognizerInstance: GestureRecognizer.Instance { return panGestureRecognizerInstance }
}
extension PanGestureRecognizer.Instance: PanGestureRecognizerInstance {
	var panGestureRecognizerInstance: PanGestureRecognizer.Instance { return self }
}

protocol PanGestureRecognizerBinding: GestureRecognizerBinding {
	static func panGestureRecognizerBinding(_ binding: PanGestureRecognizer.Binding) -> Self
}
extension PanGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return Self.panGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlPinchGestureRecognizer.swift ###

class PinchGestureRecognizer: ConstructingBinder, PinchGestureRecognizerInstance {
	typealias Instance = UIPinchGestureRecognizer
	typealias Inherited = GestureRecognizer
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var pinchGestureRecognizerInstance: Instance { return instance() }
	
	enum Binding: PinchGestureRecognizerBinding {
		typealias Binder = PinchGestureRecognizer
		static func pinchGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case scale(DynamicValue<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = PinchGestureRecognizer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .scale(let x): return x.apply(instance, storage) { i, s, v in i.scale = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: PinchGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .pinchGestureRecognizerBinding(PinchGestureRecognizer.Binding.$1(v)) }) }
	static var scale: BindingName<DynamicValue<CGFloat>, Binding> { return BindingName<DynamicValue<CGFloat>, Binding>({ v in .pinchGestureRecognizerBinding(PinchGestureRecognizer.Binding.scale(v)) }) }
}

protocol PinchGestureRecognizerInstance: GestureRecognizerInstance {
	var pinchGestureRecognizerInstance: PinchGestureRecognizer.Instance { get }
}
extension PinchGestureRecognizerInstance {
	var gestureRecognizerInstance: GestureRecognizer.Instance { return pinchGestureRecognizerInstance }
}
extension PinchGestureRecognizer.Instance: PinchGestureRecognizerInstance {
	var pinchGestureRecognizerInstance: PinchGestureRecognizer.Instance { return self }
}

protocol PinchGestureRecognizerBinding: GestureRecognizerBinding {
	static func pinchGestureRecognizerBinding(_ binding: PinchGestureRecognizer.Binding) -> Self
}
extension PinchGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return Self.pinchGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlControl.swift ###

class Control: ConstructingBinder, ControlInstance {
	typealias Instance = UIControl
	typealias Inherited = View
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var controlInstance: Instance { return instance() }
	
	enum Binding: ControlBinding {
		typealias Binder = Control
		static func controlBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case isEnabled(DynamicValue<Bool>)
		case isSelected(DynamicValue<Bool>)
		case isHighlighted(DynamicValue<Bool>)
		case contentVerticalAlignment(DynamicValue<UIControlContentVerticalAlignment>)
		case contentHorizontalAlignment(DynamicValue<UIControlContentHorizontalAlignment>)
		case actions(DynamicValue<ControlActions>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = Control
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .isEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isEnabled = v }
			case .isSelected(let x): return x.apply(instance, storage) { i, s, v in i.isSelected = v }
			case .isHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.isHighlighted = v }
			case .contentVerticalAlignment(let x): return x.apply(instance, storage) { i, s, v in i.contentVerticalAlignment = v }
			case .contentHorizontalAlignment(let x): return x.apply(instance, storage) { i, s, v in i.contentHorizontalAlignment = v }
			case .actions(let x):
				var previous: ScopedValues<UIControlEvents, TargetAction<(control: UIControl, event: UIEvent)>>? = nil
				var junctions = [Cancellable]()
				var cancellable = x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.removeTarget(nil, action: nil, for: c.0)
						}
					}
					previous = v
					junctions.removeAll()
					for c in v.pairs {
						switch c.1 {
						case .firstResponder(let s):
							i.addTarget(nil, action: s, for: c.0)
						case .singleTarget(let s):
							let target = SignalControlEventActionTarget()
							i.addTarget(target, action: target.selector, for: c.0)
							junctions += target.signal.map({ ($0.0, $0.1) as (control: UIControl, event: UIEvent) }).cancellableBind(to: s)
						}
					}
				}
				return OnDelete {
					for var j in junctions {
						j.cancel()
					}
					cancellable?.cancel()
				}
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = View.Storage
}

extension BindingName where Binding: ControlBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .controlBinding(Control.Binding.$1(v)) }) }
	static var isEnabled: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .controlBinding(Control.Binding.isEnabled(v)) }) }
	static var isSelected: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .controlBinding(Control.Binding.isSelected(v)) }) }
	static var isHighlighted: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .controlBinding(Control.Binding.isHighlighted(v)) }) }
	static var contentVerticalAlignment: BindingName<DynamicValue<UIControlContentVerticalAlignment>, Binding> { return BindingName<DynamicValue<UIControlContentVerticalAlignment>, Binding>({ v in .controlBinding(Control.Binding.contentVerticalAlignment(v)) }) }
	static var contentHorizontalAlignment: BindingName<DynamicValue<UIControlContentHorizontalAlignment>, Binding> { return BindingName<DynamicValue<UIControlContentHorizontalAlignment>, Binding>({ v in .controlBinding(Control.Binding.contentHorizontalAlignment(v)) }) }
	static var actions: BindingName<DynamicValue<ControlActions>, Binding> { return BindingName<DynamicValue<ControlActions>, Binding>({ v in .controlBinding(Control.Binding.actions(v)) }) }
}

extension BindingName where Binding: ControlBinding {
	// This is the *preferred* construction of actions.
	static func action<Input: SignalInputInterface>(_ scope: UIControlEvents) -> BindingName<Input, Binding> where Input.InputValue == (control: UIControl, event: UIEvent) {
		return BindingName<Input, Binding>({ (v: Input) -> Binding in Binding.controlBinding(Control.Binding.actions(.fromConstant(ControlActions.value(.fromSingleTarget(v.input), for: scope)))) })
	}
}

protocol ControlInstance: ViewInstance {
	var controlInstance: Control.Instance { get }
}
extension ControlInstance {
	var viewInstance: View.Instance { return controlInstance }
}
extension Control.Instance: ControlInstance {
	var controlInstance: Control.Instance { return self }
}

protocol ControlBinding: ViewBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self
}
extension ControlBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return Self.controlBinding(.inheritedBinding(binding))
	}
}

typealias ControlActions = ScopedValues<UIControlEvents, TargetAction<(control: UIControl, event: UIEvent)>>

extension ScopedValues where Scope == UIControlState {
	static func normal(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .normal)
	}
	static func highlighted(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .highlighted)
	}
	static func disabled(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .disabled)
	}
	static func selected(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .selected)
	}
	@available(iOS 9.0, *)
	static func focused(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .focused)
	}
	static func application(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .application)
	}
	static func reserved(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .reserved)
	}
}

class SignalControlEventActionTarget: NSObject {
	private var signalInput: SignalInput<(control: UIControl, event: UIEvent)>? = nil
	
	// Ownership note: we are owned by the output signal so we only weakly retain it.
	private weak var signalOutput: SignalMulti<(control: UIControl, event: UIEvent)>? = nil
	
	/// The `signal` emits the actions received
	var signal: SignalMulti<(control: UIControl, event: UIEvent)> {
		// If there's a current signal output, return it
		if let so = signalOutput {
			return so
		}
		
		// Otherwise, create a new one
		let (i, s) = Signal<(control: UIControl, event: UIEvent)>.create { s in
			// Instead of using a `isContinuous` transform, use a `buffer` to do the same thing while capturing `self` so that we're owned by the signal.
			s.customActivation { (b: inout Array<(control: UIControl, event: UIEvent)>, e: inout Error?, r: Result<(control: UIControl, event: UIEvent)>) in
				withExtendedLifetime(self) {}
				switch r {
				case .success(let v):
					b.removeAll(keepingCapacity: true)
					b.append(v)
				case .failure(let err):
					e = err
				}
			}
		}
		self.signalInput = i
		self.signalOutput = s
		return s
	}
	
	/// Receiver function for the target-action events
	///
	/// - Parameter sender: typical target-action "sender" parameter
	@IBAction func cwlSignalAction(_ sender: UIButton, forEvent event: UIEvent) {
		_ = signalInput?.send(value: (sender, event))
	}
	
	/// Convenience accessor for `#selector(SignalActionTarget<Value>.action(_:))`
	var selector: Selector { return #selector(SignalControlEventActionTarget.cwlSignalAction(_:forEvent:)) }
}


// MARK: ### CwlTextInputTraits.swift ###

struct TextInputTraits {
	let bindings: [Binding]
	init(bindings: [Binding]) {
		self.bindings = bindings
	}
	init(_ bindings: Binding...) {
		self.init(bindings: bindings)
	}
	
	enum Binding {
		case autocapitalizationType(DynamicValue<UITextAutocapitalizationType>)
		case autocorrectionType(DynamicValue<UITextAutocorrectionType>)
		case spellCheckingType(DynamicValue<UITextSpellCheckingType>)
		case enablesReturnKeyAutomatically(DynamicValue<Bool>)
		case keyboardAppearance(DynamicValue<UIKeyboardAppearance>)
		case keyboardType(DynamicValue<UIKeyboardType>)
		case returnKeyType(DynamicValue<UIReturnKeyType>)
		@available(iOS 11.0, *)
		case smartDashesType(DynamicValue<UITextSmartDashesType>)
		@available(iOS 11.0, *)
		case smartQuotesType(DynamicValue<UITextSmartQuotesType>)
		@available(iOS 11.0, *)
		case smartInsertDeleteType(DynamicValue<UITextSmartInsertDeleteType>)
		case isSecureTextEntry(DynamicValue<Bool>)
		@available(iOS 10.0, *)
		case textContentType(DynamicValue<UITextContentType>)
	}
}

extension BindingName where Binding == TextInputTraits.Binding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in TextInputTraits.$1(v) }) }
	static var autocapitalizationType: BindingName<DynamicValue<UITextAutocapitalizationType>, Binding> { return BindingName<DynamicValue<UITextAutocapitalizationType>, Binding>({ v in TextInputTraits.Binding.autocapitalizationType(v) }) }
	static var autocorrectionType: BindingName<DynamicValue<UITextAutocorrectionType>, Binding> { return BindingName<DynamicValue<UITextAutocorrectionType>, Binding>({ v in TextInputTraits.Binding.autocorrectionType(v) }) }
	static var spellCheckingType: BindingName<DynamicValue<UITextSpellCheckingType>, Binding> { return BindingName<DynamicValue<UITextSpellCheckingType>, Binding>({ v in TextInputTraits.Binding.spellCheckingType(v) }) }
	static var enablesReturnKeyAutomatically: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in TextInputTraits.Binding.enablesReturnKeyAutomatically(v) }) }
	static var keyboardAppearance: BindingName<DynamicValue<UIKeyboardAppearance>, Binding> { return BindingName<DynamicValue<UIKeyboardAppearance>, Binding>({ v in TextInputTraits.Binding.keyboardAppearance(v) }) }
	static var keyboardType: BindingName<DynamicValue<UIKeyboardType>, Binding> { return BindingName<DynamicValue<UIKeyboardType>, Binding>({ v in TextInputTraits.Binding.keyboardType(v) }) }
	static var returnKeyType: BindingName<DynamicValue<UIReturnKeyType>, Binding> { return BindingName<DynamicValue<UIReturnKeyType>, Binding>({ v in TextInputTraits.Binding.returnKeyType(v) }) }
	@available(iOS 11.0, *)
	static var smartDashesType: BindingName<DynamicValue<UITextSmartDashesType>, Binding> { return BindingName<DynamicValue<UITextSmartDashesType>, Binding>({ v in TextInputTraits.Binding.smartDashesType(v) }) }
	@available(iOS 11.0, *)
	static var smartQuotesType: BindingName<DynamicValue<UITextSmartQuotesType>, Binding> { return BindingName<DynamicValue<UITextSmartQuotesType>, Binding>({ v in TextInputTraits.Binding.smartQuotesType(v) }) }
	@available(iOS 11.0, *)
	static var smartInsertDeleteType: BindingName<DynamicValue<UITextSmartInsertDeleteType>, Binding> { return BindingName<DynamicValue<UITextSmartInsertDeleteType>, Binding>({ v in TextInputTraits.Binding.smartInsertDeleteType(v) }) }
	static var isSecureTextEntry: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in TextInputTraits.Binding.isSecureTextEntry(v) }) }
	@available(iOS 10.0, *)
	static var textContentType: BindingName<DynamicValue<UITextContentType>, Binding> { return BindingName<DynamicValue<UITextContentType>, Binding>({ v in TextInputTraits.Binding.textContentType(v) }) }
}

// MARK: ### CwlSearchBar.swift ###

class SearchBar: ConstructingBinder, SearchBarInstance {
	typealias Instance = UISearchBar
	typealias Inherited = View
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var searchBarInstance: Instance { return instance() }
	
	enum Binding: SearchBarBinding {
		typealias Binder = SearchBar
		static func searchBarBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case textInputTraits(StaticValue<TextInputTraits>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case placeholder(DynamicValue<String>)
		case prompt(DynamicValue<String>)
		case text(DynamicValue<String>)
		case barStyle(DynamicValue<UIBarStyle>)
		case tintColor(DynamicValue<UIColor>)
		case isTranslucent(DynamicValue<Bool>)
		case showsBookmarkButton(DynamicValue<Bool>)
		case showsSearchResultsButton(DynamicValue<Bool>)
		case showCancelButton(DynamicValue<SetOrAnimate<Bool>>)
		case scopeButtonTitles(DynamicValue<[String]?>)
		case selectedScopeButtonIndex(DynamicValue<Int>)
		case showsScopeBar(DynamicValue<Bool>)
		case backgroundImage(DynamicValue<ScopedValues<PositionAndMetrics, UIImage?>>)
		case image(DynamicValue<ScopedValues<IconAndControlState, UIImage?>>)
		case positionAdjustment(DynamicValue<ScopedValues<UISearchBarIcon, UIOffset>>)
		case inputAccessoryView(DynamicValue<UIView?>)
		case scopeBarButtonBackgroundImage(DynamicValue<ScopedValues<UIControlState, UIImage?>>)
		case scopeBarButtonDividerImage(DynamicValue<ScopedValues<LeftRightControlState, UIImage?>>)
		case scopeBarButtonTitleTextAttributes(DynamicValue<ScopedValues<UIControlState, [String: Any]?>>)
		case searchFieldBackgroundImage(DynamicValue<ScopedValues<UIControlState, UIImage?>>)
		case searchFieldBackgroundPositionAdjustment(DynamicValue<UIOffset>)
		case searchTextPositionAdjustment(DynamicValue<UIOffset>)

		// 2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.
		case didChange(SignalInput<String>)
		case didBeginEditing(SignalInput<()>)
		case didEndEditing(SignalInput<()>)
		case bookmarkButtonClicked(SignalInput<()>)
		case cancelButtonClicked(SignalInput<()>)
		case searchButtonClicked(SignalInput<String>)
		case resultsListButtonClicked(SignalInput<()>)
		case selectedScopeButtonIndexDidChange(SignalInput<Int>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldChangeText((NSRange, String) -> Bool)
		case shouldBeginEditing((UISearchBar) -> Bool)
		case shouldEndEditing((UISearchBar) -> Bool)
		case position((UIBarPositioning) -> UIBarPosition)
	}

	struct Preparer: ConstructingPreparer {
		typealias Binder = SearchBar
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }

		init() {
			self.init(delegateClass: Delegate.self)
		}
		init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}

		mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .didChange(let x):
				let s = #selector(UISearchBarDelegate.searchBar(_:textDidChange:))
				delegate().addSelector(s).didChange = x
			case .didBeginEditing(let x):
				let s = #selector(UISearchBarDelegate.searchBarTextDidBeginEditing(_:))
				delegate().addSelector(s).didBeginEditing = x
			case .didEndEditing(let x):
				let s = #selector(UISearchBarDelegate.searchBarTextDidEndEditing(_:))
				delegate().addSelector(s).didEndEditing = x
			case .bookmarkButtonClicked(let x):
				let s = #selector(UISearchBarDelegate.searchBarBookmarkButtonClicked(_:))
				delegate().addSelector(s).bookmarkButtonClicked = x
			case .cancelButtonClicked(let x):
				let s = #selector(UISearchBarDelegate.searchBarCancelButtonClicked(_:))
				delegate().addSelector(s).cancelButtonClicked = x
			case .searchButtonClicked(let x):
				let s = #selector(UISearchBarDelegate.searchBarSearchButtonClicked(_:))
				delegate().addSelector(s).searchButtonClicked = x
			case .resultsListButtonClicked(let x):
				let s = #selector(UISearchBarDelegate.searchBarResultsListButtonClicked(_:))
				delegate().addSelector(s).resultsListButtonClicked = x
			case .selectedScopeButtonIndexDidChange(let x):
				let s = #selector(UISearchBarDelegate.searchBar(_:selectedScopeButtonIndexDidChange:))
				delegate().addSelector(s).selectedScopeButtonIndexDidChange = x
			case .shouldChangeText(let x):
				let s = #selector(UISearchBarDelegate.searchBar(_:shouldChangeTextIn:replacementText:))
				delegate().addSelector(s).shouldChangeText = x
			case .shouldBeginEditing(let x):
				let s = #selector(UISearchBarDelegate.searchBarShouldBeginEditing(_:))
				delegate().addSelector(s).shouldBeginEditing = x
			case .shouldEndEditing(let x):
				let s = #selector(UISearchBarDelegate.searchBarShouldEndEditing(_:))
				delegate().addSelector(s).shouldEndEditing = x
			case .position(let x):
				let s = #selector(UISearchBarDelegate.position(for:))
				delegate().addSelector(s).position = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}

		mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			if storage.inUse {
				instance.delegate = storage
			}

			linkedPreparer.prepareInstance(instance, storage: storage)
		}

		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .textInputTraits(let x):
				return ArrayOfCancellables(x.value.bindings.lazy.flatMap { trait in
					switch trait {
					case .autocapitalizationType(let y): return y.apply(instance, storage) { i, s, v in i.autocapitalizationType = v }
					case .autocorrectionType(let y): return y.apply(instance, storage) { i, s, v in i.autocorrectionType = v }
					case .spellCheckingType(let y): return y.apply(instance, storage) { i, s, v in i.spellCheckingType = v }
					case .enablesReturnKeyAutomatically(let y): return y.apply(instance, storage) { i, s, v in i.enablesReturnKeyAutomatically = v }
					case .keyboardAppearance(let y): return y.apply(instance, storage) { i, s, v in i.keyboardAppearance = v }
					case .keyboardType(let y): return y.apply(instance, storage) { i, s, v in i.keyboardType = v }
					case .returnKeyType(let y): return y.apply(instance, storage) { i, s, v in i.returnKeyType = v }
					case .isSecureTextEntry(let y): return y.apply(instance, storage) { i, s, v in i.isSecureTextEntry = v }
					case .textContentType(let y):
						return y.apply(instance, storage) { i, s, v in
							if #available(iOS 10.0, *) {
								i.textContentType = v
							}
						}
					case .smartDashesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartDashesType = v
							}
						}
					case .smartQuotesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartQuotesType = v
							}
						}
					case .smartInsertDeleteType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartInsertDeleteType = v
							}
						}
					}
				})
			case .placeholder(let x): return x.apply(instance, storage) { i, s, v in i.placeholder = v }
			case .prompt(let x): return x.apply(instance, storage) { i, s, v in i.prompt = v }
			case .text(let x): return x.apply(instance, storage) { i, s, v in i.text = v }
			case .barStyle(let x): return x.apply(instance, storage) { i, s, v in i.barStyle = v }
			case .tintColor(let x): return x.apply(instance, storage) { i, s, v in i.tintColor = v }
			case .isTranslucent(let x): return x.apply(instance, storage) { i, s, v in i.isTranslucent = v }
			case .showsBookmarkButton(let x): return x.apply(instance, storage) { i, s, v in i.showsBookmarkButton = v }
			case .showsSearchResultsButton(let x): return x.apply(instance, storage) { i, s, v in i.showsSearchResultsButton = v }
			case .showCancelButton(let x): return x.apply(instance, storage) { i, s, v in i.setShowsCancelButton(v.value, animated: v.isAnimated) }
			case .scopeButtonTitles(let x): return x.apply(instance, storage) { i, s, v in i.scopeButtonTitles = v }
			case .selectedScopeButtonIndex(let x): return x.apply(instance, storage) { i, s, v in i.selectedScopeButtonIndex = v }
			case .showsScopeBar(let x): return x.apply(instance, storage) { i, s, v in i.showsScopeBar = v }
			case .inputAccessoryView(let x): return x.apply(instance, storage) { i, s, v in i.inputAccessoryView = v }
			case .searchFieldBackgroundPositionAdjustment(let x): return x.apply(instance, storage) { i, s, v in i.searchFieldBackgroundPositionAdjustment = v }
			case .searchTextPositionAdjustment(let x): return x.apply(instance, storage) { i, s, v in i.searchTextPositionAdjustment = v }
			
			case .backgroundImage(let x):
				var previous: ScopedValues<PositionAndMetrics, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for conditions in p.pairs {
							if conditions.value != nil {
								i.setBackgroundImage(nil, for: conditions.scope.barPosition, barMetrics: conditions.scope.barMetrics)
							}
						}
					}
					previous = v
					for conditions in v.pairs {
						if let image = conditions.value {
							i.setBackgroundImage(image, for: conditions.scope.barPosition, barMetrics: conditions.scope.barMetrics)
						}
					}
				}
			case .image(let x):
				var previous: ScopedValues<IconAndControlState, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for conditions in p.pairs {
							if conditions.value != nil {
								i.setImage(nil, for: conditions.scope.icon, state: conditions.scope.controlState)
							}
						}
					}
					previous = v
					for conditions in v.pairs {
						if let image = conditions.value {
							i.setImage(image, for: conditions.scope.icon, state: conditions.scope.controlState)
						}
					}
				}
			case .positionAdjustment(let x):
				var previous: ScopedValues<UISearchBarIcon, UIOffset>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setPositionAdjustment(UIOffset.zero, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setPositionAdjustment(c.1, for: c.0)
					}
				}
			case .scopeBarButtonBackgroundImage(let x):
				var previous: ScopedValues<UIControlState, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setScopeBarButtonBackgroundImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setScopeBarButtonBackgroundImage(c.1, for: c.0)
					}
				}
			case .scopeBarButtonDividerImage(let x):
				var previous: ScopedValues<LeftRightControlState, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v -> Void in
					if let p = previous {
						for conditions in p.pairs {
							i.setScopeBarButtonDividerImage(nil, forLeftSegmentState: conditions.scope.left, rightSegmentState: conditions.scope.right)
						}
					}
					previous = v
					for conditions in v.pairs {
						i.setScopeBarButtonDividerImage(conditions.value, forLeftSegmentState: conditions.scope.left, rightSegmentState: conditions.scope.right)
					}
				}
			case .scopeBarButtonTitleTextAttributes(let x):
				var previous: ScopedValues<UIControlState, [String: Any]?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setScopeBarButtonTitleTextAttributes(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setScopeBarButtonTitleTextAttributes(c.1, for: c.0)
					}
				}
			case .searchFieldBackgroundImage(let x):
				var previous: ScopedValues<UIControlState, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setScopeBarButtonBackgroundImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setScopeBarButtonBackgroundImage(c.1, for: c.0)
					}
				}
			case .didChange: return nil
			case .didBeginEditing: return nil
			case .didEndEditing: return nil
			case .bookmarkButtonClicked: return nil
			case .cancelButtonClicked: return nil
			case .searchButtonClicked: return nil
			case .resultsListButtonClicked: return nil
			case .selectedScopeButtonIndexDidChange: return nil
			case .shouldChangeText: return nil
			case .shouldBeginEditing: return nil
			case .shouldEndEditing: return nil
			case .position: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	class Storage: View.Storage, UISearchBarDelegate {}
	
	class Delegate: DynamicDelegate, UISearchBarDelegate {
		required override init() {
			super.init()
		}
		
		var didChange: SignalInput<String>?
		func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
			didChange!.send(value: searchText)
		}
		
		var didBeginEditing: SignalInput<()>?
		func searchBarTextDidBeginEditing(_ searchBar: UISearchBar) {
			didBeginEditing!.send(value: ())
		}
		
		var didEndEditing: SignalInput<()>?
		func searchBarTextDidEndEditing(_ searchBar: UISearchBar) {
			didEndEditing!.send(value: ())
		}
		
		var bookmarkButtonClicked: SignalInput<()>?
		func searchBarBookmarkButtonClicked(_ searchBar: UISearchBar) {
			bookmarkButtonClicked!.send(value: ())
		}
		
		var cancelButtonClicked: SignalInput<()>?
		func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
			cancelButtonClicked!.send(value: ())
		}
		
		var searchButtonClicked: SignalInput<String>?
		func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
			searchButtonClicked!.send(value: searchBar.text ?? "")
		}
		
		var resultsListButtonClicked: SignalInput<()>?
		func searchBarResultsListButtonClicked(_ searchBar: UISearchBar) {
			resultsListButtonClicked!.send(value: ())
		}
		
		var selectedScopeButtonIndexDidChange: SignalInput<Int>?
		func searchBarSelectedScopeButtonIndexDidChange(_ searchBar: UISearchBar, selectedScopeButtonIndexDidChange selectedScope: Int) {
			selectedScopeButtonIndexDidChange!.send(value: selectedScope)
		}
		
		var shouldBeginEditing: ((_ searchBar: UISearchBar) -> Bool)?
		func searchBarShouldBeginEditing(_ searchBar: UISearchBar) -> Bool {
			return shouldBeginEditing!(searchBar)
		}
		
		var shouldEndEditing: ((_ searchBar: UISearchBar) -> Bool)?
		func searchBarShouldEndEditing(_ searchBar: UISearchBar) -> Bool {
			return shouldEndEditing!(searchBar)
		}
		
		var shouldChangeText: ((_ range: NSRange, _ replacementString: String) -> Bool)?
		func searchBar(_ searchBar: UISearchBar, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
			return shouldChangeText!(range, text)
		}
		
		var position: ((UIBarPositioning) -> UIBarPosition)?
		func position(for bar: UIBarPositioning) -> UIBarPosition {
			return position!(bar)
		}
	}
}

extension BindingName where Binding: SearchBarBinding {
	// You can easily convert the `Binding` cases to `BindingName` by copying them to here and using the following Xcode-style regex:
	// Find:    case ([^\(]+)\((.+)\)$
	// Replace: static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .searchBarBinding(SearchBar.Binding.$1(v)) }) }
	static var textInputTraits: BindingName<StaticValue<TextInputTraits>, Binding> { return BindingName<StaticValue<TextInputTraits>, Binding>({ v in .searchBarBinding(SearchBar.Binding.textInputTraits(v)) }) }
	static var placeholder: BindingName<DynamicValue<String>, Binding> { return BindingName<DynamicValue<String>, Binding>({ v in .searchBarBinding(SearchBar.Binding.placeholder(v)) }) }
	static var prompt: BindingName<DynamicValue<String>, Binding> { return BindingName<DynamicValue<String>, Binding>({ v in .searchBarBinding(SearchBar.Binding.prompt(v)) }) }
	static var text: BindingName<DynamicValue<String>, Binding> { return BindingName<DynamicValue<String>, Binding>({ v in .searchBarBinding(SearchBar.Binding.text(v)) }) }
	static var barStyle: BindingName<DynamicValue<UIBarStyle>, Binding> { return BindingName<DynamicValue<UIBarStyle>, Binding>({ v in .searchBarBinding(SearchBar.Binding.barStyle(v)) }) }
	static var tintColor: BindingName<DynamicValue<UIColor>, Binding> { return BindingName<DynamicValue<UIColor>, Binding>({ v in .searchBarBinding(SearchBar.Binding.tintColor(v)) }) }
	static var isTranslucent: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .searchBarBinding(SearchBar.Binding.isTranslucent(v)) }) }
	static var showsBookmarkButton: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .searchBarBinding(SearchBar.Binding.showsBookmarkButton(v)) }) }
	static var showsSearchResultsButton: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .searchBarBinding(SearchBar.Binding.showsSearchResultsButton(v)) }) }
	static var showCancelButton: BindingName<DynamicValue<SetOrAnimate<Bool>>, Binding> { return BindingName<DynamicValue<SetOrAnimate<Bool>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.showCancelButton(v)) }) }
	static var scopeButtonTitles: BindingName<DynamicValue<[String]?>, Binding> { return BindingName<DynamicValue<[String]?>, Binding>({ v in .searchBarBinding(SearchBar.Binding.scopeButtonTitles(v)) }) }
	static var selectedScopeButtonIndex: BindingName<DynamicValue<Int>, Binding> { return BindingName<DynamicValue<Int>, Binding>({ v in .searchBarBinding(SearchBar.Binding.selectedScopeButtonIndex(v)) }) }
	static var showsScopeBar: BindingName<DynamicValue<Bool>, Binding> { return BindingName<DynamicValue<Bool>, Binding>({ v in .searchBarBinding(SearchBar.Binding.showsScopeBar(v)) }) }
	static var backgroundImage: BindingName<DynamicValue<ScopedValues<PositionAndMetrics, UIImage?>>, Binding> { return BindingName<DynamicValue<ScopedValues<PositionAndMetrics, UIImage?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.backgroundImage(v)) }) }
	static var image: BindingName<DynamicValue<ScopedValues<IconAndControlState, UIImage?>>, Binding> { return BindingName<DynamicValue<ScopedValues<IconAndControlState, UIImage?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.image(v)) }) }
	static var positionAdjustment: BindingName<DynamicValue<ScopedValues<UISearchBarIcon, UIOffset>>, Binding> { return BindingName<DynamicValue<ScopedValues<UISearchBarIcon, UIOffset>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.positionAdjustment(v)) }) }
	static var inputAccessoryView: BindingName<DynamicValue<UIView?>, Binding> { return BindingName<DynamicValue<UIView?>, Binding>({ v in .searchBarBinding(SearchBar.Binding.inputAccessoryView(v)) }) }
	static var scopeBarButtonBackgroundImage: BindingName<DynamicValue<ScopedValues<UIControlState, UIImage?>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIControlState, UIImage?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.scopeBarButtonBackgroundImage(v)) }) }
	static var scopeBarButtonDividerImage: BindingName<DynamicValue<ScopedValues<LeftRightControlState, UIImage?>>, Binding> { return BindingName<DynamicValue<ScopedValues<LeftRightControlState, UIImage?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.scopeBarButtonDividerImage(v)) }) }
	static var scopeBarButtonTitleTextAttributes: BindingName<DynamicValue<ScopedValues<UIControlState, [String: Any]?>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIControlState, [String: Any]?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.scopeBarButtonTitleTextAttributes(v)) }) }
	static var searchFieldBackgroundImage: BindingName<DynamicValue<ScopedValues<UIControlState, UIImage?>>, Binding> { return BindingName<DynamicValue<ScopedValues<UIControlState, UIImage?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.searchFieldBackgroundImage(v)) }) }
	static var searchFieldBackgroundPositionAdjustment: BindingName<DynamicValue<UIOffset>, Binding> { return BindingName<DynamicValue<UIOffset>, Binding>({ v in .searchBarBinding(SearchBar.Binding.searchFieldBackgroundPositionAdjustment(v)) }) }
	static var searchTextPositionAdjustment: BindingName<DynamicValue<UIOffset>, Binding> { return BindingName<DynamicValue<UIOffset>, Binding>({ v in .searchBarBinding(SearchBar.Binding.searchTextPositionAdjustment(v)) }) }
	static var didChange: BindingName<SignalInput<String>, Binding> { return BindingName<SignalInput<String>, Binding>({ v in .searchBarBinding(SearchBar.Binding.didChange(v)) }) }
	static var didBeginEditing: BindingName<SignalInput<()>, Binding> { return BindingName<SignalInput<()>, Binding>({ v in .searchBarBinding(SearchBar.Binding.didBeginEditing(v)) }) }
	static var didEndEditing: BindingName<SignalInput<()>, Binding> { return BindingName<SignalInput<()>, Binding>({ v in .searchBarBinding(SearchBar.Binding.didEndEditing(v)) }) }
	static var bookmarkButtonClicked: BindingName<SignalInput<()>, Binding> { return BindingName<SignalInput<()>, Binding>({ v in .searchBarBinding(SearchBar.Binding.bookmarkButtonClicked(v)) }) }
	static var cancelButtonClicked: BindingName<SignalInput<()>, Binding> { return BindingName<SignalInput<()>, Binding>({ v in .searchBarBinding(SearchBar.Binding.cancelButtonClicked(v)) }) }
	static var searchButtonClicked: BindingName<SignalInput<String>, Binding> { return BindingName<SignalInput<String>, Binding>({ v in .searchBarBinding(SearchBar.Binding.searchButtonClicked(v)) }) }
	static var resultsListButtonClicked: BindingName<SignalInput<()>, Binding> { return BindingName<SignalInput<()>, Binding>({ v in .searchBarBinding(SearchBar.Binding.resultsListButtonClicked(v)) }) }
	static var selectedScopeButtonIndexDidChange: BindingName<SignalInput<Int>, Binding> { return BindingName<SignalInput<Int>, Binding>({ v in .searchBarBinding(SearchBar.Binding.selectedScopeButtonIndexDidChange(v)) }) }
	static var shouldChangeText: BindingName<(NSRange, String) -> Bool, Binding> { return BindingName<(NSRange, String) -> Bool, Binding>({ v in .searchBarBinding(SearchBar.Binding.shouldChangeText(v)) }) }
	static var shouldBeginEditing: BindingName<(UISearchBar) -> Bool, Binding> { return BindingName<(UISearchBar) -> Bool, Binding>({ v in .searchBarBinding(SearchBar.Binding.shouldBeginEditing(v)) }) }
	static var shouldEndEditing: BindingName<(UISearchBar) -> Bool, Binding> { return BindingName<(UISearchBar) -> Bool, Binding>({ v in .searchBarBinding(SearchBar.Binding.shouldEndEditing(v)) }) }
	static var position: BindingName<(UIBarPositioning) -> UIBarPosition, Binding> { return BindingName<(UIBarPositioning) -> UIBarPosition, Binding>({ v in .searchBarBinding(SearchBar.Binding.position(v)) }) }
}

protocol SearchBarInstance: ViewInstance {
	var searchBarInstance: SearchBar.Instance { get }
}
extension SearchBarInstance {
	var viewInstance: View.Instance { return searchBarInstance }
}
extension SearchBar.Instance: SearchBarInstance {
	var searchBarInstance: SearchBar.Instance {
		return self
	}
}

protocol SearchBarBinding: ViewBinding {
	static func searchBarBinding(_ binding: SearchBar.Binding) -> Self
}
extension SearchBarBinding {
	static func viewBinding(_ binding: View.Binding) -> Self {
		return Self.searchBarBinding(.inheritedBinding(binding))
	}
}

struct LeftRightControlState {
	let left: UIControlState
	let right: UIControlState
	init(left: UIControlState = .normal, right: UIControlState = .normal) {
		self.left = left
		self.right = right
	}
}

struct IconAndControlState {
	let icon: UISearchBarIcon
	let controlState: UIControlState
	init(icon: UISearchBarIcon = .search, state: UIControlState = .normal) {
		self.icon = icon
		self.controlState = state
	}
}

extension ScopedValues where Scope == LeftRightControlState {
	static func normal(right: UIControlState = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .normal, right: right))
	}
	static func highlighted(right: UIControlState = .highlighted, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .highlighted, right: right))
	}
	static func disabled(right: UIControlState = .disabled, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .disabled, right: right))
	}
	static func selected(right: UIControlState = .selected, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .selected, right: right))
	}
	@available(iOS 9.0, *)
	static func focused(right: UIControlState = .focused, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .focused, right: right))
	}
	static func application(right: UIControlState = .application, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .application, right: right))
	}
	static func reserved(right: UIControlState = .reserved, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .reserved, right: right))
	}
}

extension ScopedValues where Scope == IconAndControlState {
	static func search(state: UIControlState = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .search, state: state))
	}
	static func clear(state: UIControlState = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .clear, state: state))
	}
	static func bookmark(state: UIControlState = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .bookmark, state: state))
	}
	static func resultsList(state: UIControlState = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .resultsList, state: state))
	}
}

extension ScopedValues where Scope == UISearchBarIcon {
	static func search(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .search)
	}
	static func clear(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .clear)
	}
	static func bookmark(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .bookmark)
	}
	static func resultsList(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .resultsList)
	}
}

// MARK: ### CwlScreenEdgePanGestureRecognizer.swift ###

class ScreenEdgePanGestureRecognizer: ConstructingBinder, ScreenEdgePanGestureRecognizerInstance {
	typealias Instance = UIScreenEdgePanGestureRecognizer
	typealias Inherited = GestureRecognizer
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var screenEdgePanGestureRecognizerInstance: Instance { return instance() }
	
	enum Binding: ScreenEdgePanGestureRecognizerBinding {
		typealias Binder = ScreenEdgePanGestureRecognizer
		static func screenEdgePanGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case edges(DynamicValue<UIRectEdge>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		
		struct Name<Value> {
			// You can easily convert the `Binding` cases to `Binding.Name` using the following Xcode-style regex:
			// Replace: case ([^\(]+)\((.+)\)$
			// With:    static var $1: Name<$2> { return Name<$2>(Binding.$1) }
			static var edges: Name<DynamicValue<UIRectEdge>> { return Name<DynamicValue<UIRectEdge>>(Binding.edges) }
			
			let constructor: (Value) -> Binding
			init(_ constructor: @escaping (Value) -> Binding) {
				self.constructor = constructor
			}
		}
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = ScreenEdgePanGestureRecognizer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .edges(let x): return x.apply(instance, storage) { i, s, v in i.edges = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: ScreenEdgePanGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .screenEdgePanGestureRecognizerBinding(ScreenEdgePanGestureRecognizer.Binding.$1(v)) }) }
	static var edges: BindingName<DynamicValue<UIRectEdge>, Binding> { return BindingName<DynamicValue<UIRectEdge>, Binding>({ v in .screenEdgePanGestureRecognizerBinding(ScreenEdgePanGestureRecognizer.Binding.edges(v)) }) }
}

protocol ScreenEdgePanGestureRecognizerInstance: GestureRecognizerInstance {
	var screenEdgePanGestureRecognizerInstance: ScreenEdgePanGestureRecognizer.Instance { get }
}
extension ScreenEdgePanGestureRecognizerInstance {
	var gestureRecognizerInstance: GestureRecognizer.Instance { return screenEdgePanGestureRecognizerInstance }
}
extension ScreenEdgePanGestureRecognizer.Instance: ScreenEdgePanGestureRecognizerInstance {
	var screenEdgePanGestureRecognizerInstance: ScreenEdgePanGestureRecognizer.Instance { return self }
}

protocol ScreenEdgePanGestureRecognizerBinding: GestureRecognizerBinding {
	static func screenEdgePanGestureRecognizerBinding(_ binding: ScreenEdgePanGestureRecognizer.Binding) -> Self
}
extension ScreenEdgePanGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return Self.screenEdgePanGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

// MARK: ### CwlRotationGestureRecognizer.swift ###

class RotationGestureRecognizer: ConstructingBinder, RotationGestureRecognizerInstance {
	typealias Instance = UIRotationGestureRecognizer
	typealias Inherited = GestureRecognizer
	
	var state: BinderConstructionState<Instance, Binding>
	required init(subclass: Instance.Type = Instance.self, bindings: [Binding]) {
		state = .pending(BinderParameters(subclass: subclass, bindings: bindings))
	}
	static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	var rotationGestureRecognizerInstance: Instance { return instance() }
	
	enum Binding: RotationGestureRecognizerBinding {
		typealias Binder = RotationGestureRecognizer
		static func rotationGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case rotation(DynamicValue<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	struct Preparer: ConstructingPreparer {
		typealias Binder = RotationGestureRecognizer
		var linkedPreparer = Inherited.Preparer()
		
		func constructStorage() -> Binder.Storage { return Storage() }
		func constructInstance(subclass: Binder.Instance.Type) -> Binder.Instance { return subclass.init() }
		
		init() {}
		
		func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Cancellable? {
			switch binding {
			case .rotation(let x): return x.apply(instance, storage) { i, s, v in i.rotation = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: RotationGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .rotationGestureRecognizerBinding(RotationGestureRecognizer.Binding.$1(v)) }) }
	static var rotation: BindingName<DynamicValue<CGFloat>, Binding> { return BindingName<DynamicValue<CGFloat>, Binding>({ v in .rotationGestureRecognizerBinding(RotationGestureRecognizer.Binding.rotation(v)) }) }
}

protocol RotationGestureRecognizerInstance: GestureRecognizerInstance {
	var rotationGestureRecognizerInstance: RotationGestureRecognizer.Instance { get }
}
extension RotationGestureRecognizerInstance {
	var gestureRecognizerInstance: GestureRecognizer.Instance { return rotationGestureRecognizerInstance }
}
extension RotationGestureRecognizer.Instance: RotationGestureRecognizerInstance {
	var rotationGestureRecognizerInstance: RotationGestureRecognizer.Instance { return self }
}

protocol RotationGestureRecognizerBinding: GestureRecognizerBinding {
	static func rotationGestureRecognizerBinding(_ binding: RotationGestureRecognizer.Binding) -> Self
}
extension RotationGestureRecognizerBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return Self.rotationGestureRecognizerBinding(.inheritedBinding(binding))
	}
}
