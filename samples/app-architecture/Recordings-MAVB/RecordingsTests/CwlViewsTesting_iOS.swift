//
//  This file is part of a reduced file concatenation of the CwlViews
//  framework with internal interfaces for source inclusion in projects instead
//  of library inclusion.
//  For details, visit: https://github.com/mattgallagher/CwlViews
//
//  Copyright Â© 2015-2018 Matt Gallagher ( http://cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlUtilsConcat tool on 2018-04-02 04:01:20 +0000 from the following files:
//
//    Core/CwlBindingParser.swift
//    iOS/CwlTableViewCellTesting.swift
//    iOS/CwlViewControllerTesting.swift
//    iOS/CwlLabelTesting.swift
//    iOS/CwlNavigationItemTesting.swift
//    iOS/CwlViewTesting.swift
//    iOS/CwlBarButtonItemTesting.swift
//    iOS/CwlTableViewTesting.swift
//

@testable import Recordings

#if os(macOS)
	import AppKit
#else
	import UIKit
#endif

// MARK: ### CwlBindingParser.swift ###

struct BindingParser<AssociatedValue, Binding> {
	var parse: (Binding) -> AssociatedValue?
	init(parse: @escaping (Binding) -> AssociatedValue?) {
		self.parse = parse
	}
}

enum BindingParserErrors: Error {
	case multipleMatchesFound
	case noMatchesFound
	case unexpectedArgumentType
}

extension Binder {
	static func consumeBindings(from possibleBinder: Any) throws -> [Self.Binding] {
		if let b = possibleBinder as? Self {
			return b.consumeBindings()
		}
		throw BindingParserErrors.unexpectedArgumentType
	}
}

extension BaseBinding {
	static func value<AssociatedValue, S: Sequence>(for parser: BindingParser<DynamicValue<AssociatedValue>, Self>, in bindings: S) throws -> AssociatedValue where S.Element == Self {
		var found: AssociatedValue? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.captureValues().last
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func valuesArray<AssociatedValue, S: Sequence>(for parser: BindingParser<DynamicValue<AssociatedValue>, Self>, in bindings: S) throws -> [AssociatedValue] where S.Element == Self {
		var found: [AssociatedValue]? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.captureValues()
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
 	static func value<AssociatedValue, S: Sequence>(for parser: BindingParser<StaticValue<AssociatedValue>, Self>, in bindings: S) throws -> AssociatedValue where S.Element == Self {
		var found: AssociatedValue? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.value
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func signal<AssociatedValue, S: Sequence>(for parser: BindingParser<DynamicValue<AssociatedValue>, Self>, in bindings: S) throws -> Signal<AssociatedValue> where S.Element == Self {
		var found: Signal<AssociatedValue>? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v.signal()
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
	
	static func argument<AssociatedValue, S: Sequence>(for parser: BindingParser<AssociatedValue, Self>, in bindings: S) throws -> AssociatedValue where S.Element == Self {
		var found: AssociatedValue? = nil
		for b in bindings {
			if let v = parser.parse(b) {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				found = v
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
}

// MARK: ### CwlTableViewCellTesting.swift ###

extension BindingParser where Binding == TableViewCell.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }

	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var cellStyle: BindingParser<StaticValue<UITableViewCellStyle>, Binding> { return BindingParser<StaticValue<UITableViewCellStyle>, Binding>(parse: { binding -> Optional<StaticValue<UITableViewCellStyle>> in if case .cellStyle(let x) = binding { return x } else { return nil } }) }
	static var textLabel: BindingParser<StaticValue<Label>, Binding> { return BindingParser<StaticValue<Label>, Binding>(parse: { binding -> Optional<StaticValue<Label>> in if case .textLabel(let x) = binding { return x } else { return nil } }) }
	static var detailLabel: BindingParser<StaticValue<Label>, Binding> { return BindingParser<StaticValue<Label>, Binding>(parse: { binding -> Optional<StaticValue<Label>> in if case .detailLabel(let x) = binding { return x } else { return nil } }) }
	static var imageView: BindingParser<StaticValue<ImageView>, Binding> { return BindingParser<StaticValue<ImageView>, Binding>(parse: { binding -> Optional<StaticValue<ImageView>> in if case .imageView(let x) = binding { return x } else { return nil } }) }
	static var contentView: BindingParser<StaticValue<View>, Binding> { return BindingParser<StaticValue<View>, Binding>(parse: { binding -> Optional<StaticValue<View>> in if case .contentView(let x) = binding { return x } else { return nil } }) }
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	static var backgroundView: BindingParser<DynamicValue<ViewConvertible?>, Binding> { return BindingParser<DynamicValue<ViewConvertible?>, Binding>(parse: { binding -> Optional<DynamicValue<ViewConvertible?>> in if case .backgroundView(let x) = binding { return x } else { return nil } }) }
	static var selectedBackgroundView: BindingParser<DynamicValue<ViewConvertible?>, Binding> { return BindingParser<DynamicValue<ViewConvertible?>, Binding>(parse: { binding -> Optional<DynamicValue<ViewConvertible?>> in if case .selectedBackgroundView(let x) = binding { return x } else { return nil } }) }
	static var multipleSelectionBackgroundView: BindingParser<DynamicValue<ViewConvertible?>, Binding> { return BindingParser<DynamicValue<ViewConvertible?>, Binding>(parse: { binding -> Optional<DynamicValue<ViewConvertible?>> in if case .multipleSelectionBackgroundView(let x) = binding { return x } else { return nil } }) }
	static var accessoryType: BindingParser<DynamicValue<UITableViewCellAccessoryType>, Binding> { return BindingParser<DynamicValue<UITableViewCellAccessoryType>, Binding>(parse: { binding -> Optional<DynamicValue<UITableViewCellAccessoryType>> in if case .accessoryType(let x) = binding { return x } else { return nil } }) }
	static var accessoryView: BindingParser<DynamicValue<ViewConvertible>, Binding> { return BindingParser<DynamicValue<ViewConvertible>, Binding>(parse: { binding -> Optional<DynamicValue<ViewConvertible>> in if case .accessoryView(let x) = binding { return x } else { return nil } }) }
	static var editingAccessoryType: BindingParser<DynamicValue<UITableViewCellAccessoryType>, Binding> { return BindingParser<DynamicValue<UITableViewCellAccessoryType>, Binding>(parse: { binding -> Optional<DynamicValue<UITableViewCellAccessoryType>> in if case .editingAccessoryType(let x) = binding { return x } else { return nil } }) }
	static var editingAccessoryView: BindingParser<DynamicValue<ViewConvertible>, Binding> { return BindingParser<DynamicValue<ViewConvertible>, Binding>(parse: { binding -> Optional<DynamicValue<ViewConvertible>> in if case .editingAccessoryView(let x) = binding { return x } else { return nil } }) }
	static var isSelected: BindingParser<DynamicValue<SetOrAnimate<Bool>>, Binding> { return BindingParser<DynamicValue<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<DynamicValue<SetOrAnimate<Bool>>> in if case .isSelected(let x) = binding { return x } else { return nil } }) }
	static var isHighlighted: BindingParser<DynamicValue<SetOrAnimate<Bool>>, Binding> { return BindingParser<DynamicValue<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<DynamicValue<SetOrAnimate<Bool>>> in if case .isHighlighted(let x) = binding { return x } else { return nil } }) }
	static var isEditing: BindingParser<DynamicValue<SetOrAnimate<Bool>>, Binding> { return BindingParser<DynamicValue<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<DynamicValue<SetOrAnimate<Bool>>> in if case .isEditing(let x) = binding { return x } else { return nil } }) }
	static var showsReorderControl: BindingParser<DynamicValue<Bool>, Binding> { return BindingParser<DynamicValue<Bool>, Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .showsReorderControl(let x) = binding { return x } else { return nil } }) }
	static var indentationLevel: BindingParser<DynamicValue<Int>, Binding> { return BindingParser<DynamicValue<Int>, Binding>(parse: { binding -> Optional<DynamicValue<Int>> in if case .indentationLevel(let x) = binding { return x } else { return nil } }) }
	static var indentationWidth: BindingParser<DynamicValue<CGFloat>, Binding> { return BindingParser<DynamicValue<CGFloat>, Binding>(parse: { binding -> Optional<DynamicValue<CGFloat>> in if case .indentationWidth(let x) = binding { return x } else { return nil } }) }
	static var shouldIndentWhileEditing: BindingParser<DynamicValue<Bool>, Binding> { return BindingParser<DynamicValue<Bool>, Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .shouldIndentWhileEditing(let x) = binding { return x } else { return nil } }) }
	static var separatorInset: BindingParser<DynamicValue<UIEdgeInsets>, Binding> { return BindingParser<DynamicValue<UIEdgeInsets>, Binding>(parse: { binding -> Optional<DynamicValue<UIEdgeInsets>> in if case .separatorInset(let x) = binding { return x } else { return nil } }) }
	static var focusStyle: BindingParser<DynamicValue<UITableViewCellFocusStyle>, Binding> { return BindingParser<DynamicValue<UITableViewCellFocusStyle>, Binding>(parse: { binding -> Optional<DynamicValue<UITableViewCellFocusStyle>> in if case .focusStyle(let x) = binding { return x } else { return nil } }) }
}

// MARK: ### CwlViewControllerTesting.swift ###

extension BindingParser where Binding == ViewController.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	static var navigationItem: BindingParser<StaticValue<NavigationItem>, Binding> { return BindingParser<StaticValue<NavigationItem>, Binding>(parse: { binding -> Optional<StaticValue<NavigationItem>> in if case .navigationItem(let x) = binding { return x } else { return nil } }) }
	static var view: BindingParser<DynamicValue<ViewConvertible>, Binding> { return BindingParser<DynamicValue<ViewConvertible>, Binding>(parse: { binding -> Optional<DynamicValue<ViewConvertible>> in if case .view(let x) = binding { return x } else { return nil } }) }
	@available(iOS, introduced: 7.0, deprecated: 11.0, message: "This property exists to access layout guides prior to iOS 11. On iOS 11 and later, use .layout on the .view")
	static var layout: BindingParser<DynamicValue<Layout>, Binding> { return BindingParser<DynamicValue<Layout>, Binding>(parse: { binding -> Optional<DynamicValue<Layout>> in if case .layout(let x) = binding { return x } else { return nil } }) }
	static var title: BindingParser<DynamicValue<String>, Binding> { return BindingParser<DynamicValue<String>, Binding>(parse: { binding -> Optional<DynamicValue<String>> in if case .title(let x) = binding { return x } else { return nil } }) }
	static var preferredContentSize: BindingParser<DynamicValue<CGSize>, Binding> { return BindingParser<DynamicValue<CGSize>, Binding>(parse: { binding -> Optional<DynamicValue<CGSize>> in if case .preferredContentSize(let x) = binding { return x } else { return nil } }) }
	static var modalPresentationStyle: BindingParser<DynamicValue<UIModalPresentationStyle>, Binding> { return BindingParser<DynamicValue<UIModalPresentationStyle>, Binding>(parse: { binding -> Optional<DynamicValue<UIModalPresentationStyle>> in if case .modalPresentationStyle(let x) = binding { return x } else { return nil } }) }
	static var modalTransitionStyle: BindingParser<DynamicValue<UIModalTransitionStyle>, Binding> { return BindingParser<DynamicValue<UIModalTransitionStyle>, Binding>(parse: { binding -> Optional<DynamicValue<UIModalTransitionStyle>> in if case .modalTransitionStyle(let x) = binding { return x } else { return nil } }) }
	static var isModalInPopover: BindingParser<DynamicValue<Bool>, Binding> { return BindingParser<DynamicValue<Bool>, Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .isModalInPopover(let x) = binding { return x } else { return nil } }) }
	static var definesPresentationContext: BindingParser<DynamicValue<Bool>, Binding> { return BindingParser<DynamicValue<Bool>, Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .definesPresentationContext(let x) = binding { return x } else { return nil } }) }
	static var providesPresentationContextTransitionStyle: BindingParser<DynamicValue<Bool>, Binding> { return BindingParser<DynamicValue<Bool>, Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .providesPresentationContextTransitionStyle(let x) = binding { return x } else { return nil } }) }
	static var transitioningDelegate: BindingParser<DynamicValue<UIViewControllerTransitioningDelegate>, Binding> { return BindingParser<DynamicValue<UIViewControllerTransitioningDelegate>, Binding>(parse: { binding -> Optional<DynamicValue<UIViewControllerTransitioningDelegate>> in if case .transitioningDelegate(let x) = binding { return x } else { return nil } }) }
	static var edgesForExtendedLayout: BindingParser<DynamicValue<UIRectEdge>, Binding> { return BindingParser<DynamicValue<UIRectEdge>, Binding>(parse: { binding -> Optional<DynamicValue<UIRectEdge>> in if case .edgesForExtendedLayout(let x) = binding { return x } else { return nil } }) }
	static var extendedLayoutIncludesOpaqueBars: BindingParser<DynamicValue<Bool>, Binding> { return BindingParser<DynamicValue<Bool>, Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .extendedLayoutIncludesOpaqueBars(let x) = binding { return x } else { return nil } }) }
	static var automaticallyAdjustsScrollViewInsets: BindingParser<DynamicValue<Bool>, Binding> { return BindingParser<DynamicValue<Bool>, Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .automaticallyAdjustsScrollViewInsets(let x) = binding { return x } else { return nil } }) }
	static var restorationIdentifier: BindingParser<DynamicValue<String?>, Binding> { return BindingParser<DynamicValue<String?>, Binding>(parse: { binding -> Optional<DynamicValue<String?>> in if case .restorationIdentifier(let x) = binding { return x } else { return nil } }) }
	static var restorationClass: BindingParser<DynamicValue<UIViewControllerRestoration.Type?>, Binding> { return BindingParser<DynamicValue<UIViewControllerRestoration.Type?>, Binding>(parse: { binding -> Optional<DynamicValue<UIViewControllerRestoration.Type?>> in if case .restorationClass(let x) = binding { return x } else { return nil } }) }
	static var modalPresentationCapturesStatusBarAppearance: BindingParser<DynamicValue<Bool>, Binding> { return BindingParser<DynamicValue<Bool>, Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .modalPresentationCapturesStatusBarAppearance(let x) = binding { return x } else { return nil } }) }
	static var hidesBottomBarWhenPushed: BindingParser<DynamicValue<Bool>, Binding> { return BindingParser<DynamicValue<Bool>, Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .hidesBottomBarWhenPushed(let x) = binding { return x } else { return nil } }) }
	static var toolbarItems: BindingParser<DynamicValue<SetOrAnimate<[BarButtonItemConvertible]>>, Binding> { return BindingParser<DynamicValue<SetOrAnimate<[BarButtonItemConvertible]>>, Binding>(parse: { binding -> Optional<DynamicValue<SetOrAnimate<[BarButtonItemConvertible]>>> in if case .toolbarItems(let x) = binding { return x } else { return nil } }) }
	static var tabBarItem: BindingParser<DynamicValue<TabBarItemConvertible>, Binding> { return BindingParser<DynamicValue<TabBarItemConvertible>, Binding>(parse: { binding -> Optional<DynamicValue<TabBarItemConvertible>> in if case .tabBarItem(let x) = binding { return x } else { return nil } }) }
	static var isEditing: BindingParser<Signal<SetOrAnimate<Bool>>, Binding> { return BindingParser<Signal<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<Bool>>> in if case .isEditing(let x) = binding { return x } else { return nil } }) }
	static var present: BindingParser<Signal<ModalPresentation>, Binding> { return BindingParser<Signal<ModalPresentation>, Binding>(parse: { binding -> Optional<Signal<ModalPresentation>> in if case .present(let x) = binding { return x } else { return nil } }) }
	static var traitCollectionDidChange: BindingParser<SignalInput<(previous: UITraitCollection?, new: UITraitCollection)>, Binding> { return BindingParser<SignalInput<(previous: UITraitCollection?, new: UITraitCollection)>, Binding>(parse: { binding -> Optional<SignalInput<(previous: UITraitCollection?, new: UITraitCollection)>> in if case .traitCollectionDidChange(let x) = binding { return x } else { return nil } }) }
	static var willAppear: BindingParser<SignalInput<Bool>, Binding> { return BindingParser<SignalInput<Bool>, Binding>(parse: { binding -> Optional<SignalInput<Bool>> in if case .willAppear(let x) = binding { return x } else { return nil } }) }
	static var didAppear: BindingParser<SignalInput<Bool>, Binding> { return BindingParser<SignalInput<Bool>, Binding>(parse: { binding -> Optional<SignalInput<Bool>> in if case .didAppear(let x) = binding { return x } else { return nil } }) }
	static var didDisappear: BindingParser<SignalInput<Bool>, Binding> { return BindingParser<SignalInput<Bool>, Binding>(parse: { binding -> Optional<SignalInput<Bool>> in if case .didDisappear(let x) = binding { return x } else { return nil } }) }
	static var willDisappear: BindingParser<SignalInput<Bool>, Binding> { return BindingParser<SignalInput<Bool>, Binding>(parse: { binding -> Optional<SignalInput<Bool>> in if case .willDisappear(let x) = binding { return x } else { return nil } }) }
	static var loadView: BindingParser<() -> ViewConvertible, Binding> { return BindingParser<() -> ViewConvertible, Binding>(parse: { binding -> Optional<() -> ViewConvertible> in if case .loadView(let x) = binding { return x } else { return nil } }) }
	static var didReceiveMemoryWarning: BindingParser<() -> Void, Binding> { return BindingParser<() -> Void, Binding>(parse: { binding -> Optional<() -> Void> in if case .didReceiveMemoryWarning(let x) = binding { return x } else { return nil } }) }
}

// MARK: ### CwlLabelTesting.swift ###

extension BindingParser where Binding == Label.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var text: BindingParser<DynamicValue<String>, Binding> { return BindingParser<DynamicValue<String>, Binding>(parse: { binding -> Optional<DynamicValue<String>> in if case .text(let x) = binding { return x } else { return nil } }) }
	static var attributedText: BindingParser<DynamicValue<NSAttributedString?>, Binding> { return BindingParser<DynamicValue<NSAttributedString?>, Binding>(parse: { binding -> Optional<DynamicValue<NSAttributedString?>> in if case .attributedText(let x) = binding { return x } else { return nil } }) }
	static var font: BindingParser<DynamicValue<UIFont>, Binding> { return BindingParser<DynamicValue<UIFont>, Binding>(parse: { binding -> Optional<DynamicValue<UIFont>> in if case .font(let x) = binding { return x } else { return nil } }) }
	static var textColor: BindingParser<DynamicValue<UIColor>, Binding> { return BindingParser<DynamicValue<UIColor>, Binding>(parse: { binding -> Optional<DynamicValue<UIColor>> in if case .textColor(let x) = binding { return x } else { return nil } }) }
	static var textAlignment: BindingParser<DynamicValue<NSTextAlignment>, Binding> { return BindingParser<DynamicValue<NSTextAlignment>, Binding>(parse: { binding -> Optional<DynamicValue<NSTextAlignment>> in if case .textAlignment(let x) = binding { return x } else { return nil } }) }
	static var lineBreakMode: BindingParser<DynamicValue<NSLineBreakMode>, Binding> { return BindingParser<DynamicValue<NSLineBreakMode>, Binding>(parse: { binding -> Optional<DynamicValue<NSLineBreakMode>> in if case .lineBreakMode(let x) = binding { return x } else { return nil } }) }
	static var isEnabled: BindingParser<DynamicValue<Bool>, Binding> { return BindingParser<DynamicValue<Bool>, Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .isEnabled(let x) = binding { return x } else { return nil } }) }
	static var adjustsFontSizeToFitWidth: BindingParser<DynamicValue<Bool>, Binding> { return BindingParser<DynamicValue<Bool>, Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .adjustsFontSizeToFitWidth(let x) = binding { return x } else { return nil } }) }
	static var allowsDefaultTighteningForTruncation: BindingParser<DynamicValue<Bool>, Binding> { return BindingParser<DynamicValue<Bool>, Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .allowsDefaultTighteningForTruncation(let x) = binding { return x } else { return nil } }) }
	static var baselineAdjustment: BindingParser<DynamicValue<UIBaselineAdjustment>, Binding> { return BindingParser<DynamicValue<UIBaselineAdjustment>, Binding>(parse: { binding -> Optional<DynamicValue<UIBaselineAdjustment>> in if case .baselineAdjustment(let x) = binding { return x } else { return nil } }) }
	static var minimumScaleFactor: BindingParser<DynamicValue<CGFloat>, Binding> { return BindingParser<DynamicValue<CGFloat>, Binding>(parse: { binding -> Optional<DynamicValue<CGFloat>> in if case .minimumScaleFactor(let x) = binding { return x } else { return nil } }) }
	static var numberOfLines: BindingParser<DynamicValue<Int>, Binding> { return BindingParser<DynamicValue<Int>, Binding>(parse: { binding -> Optional<DynamicValue<Int>> in if case .numberOfLines(let x) = binding { return x } else { return nil } }) }
	static var highlightedTextColor: BindingParser<DynamicValue<UIColor?>, Binding> { return BindingParser<DynamicValue<UIColor?>, Binding>(parse: { binding -> Optional<DynamicValue<UIColor?>> in if case .highlightedTextColor(let x) = binding { return x } else { return nil } }) }
	static var isHighlighted: BindingParser<DynamicValue<Bool>, Binding> { return BindingParser<DynamicValue<Bool>, Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .isHighlighted(let x) = binding { return x } else { return nil } }) }
	static var shadowColor: BindingParser<DynamicValue<UIColor?>, Binding> { return BindingParser<DynamicValue<UIColor?>, Binding>(parse: { binding -> Optional<DynamicValue<UIColor?>> in if case .shadowColor(let x) = binding { return x } else { return nil } }) }
	static var shadowOffset: BindingParser<DynamicValue<CGSize>, Binding> { return BindingParser<DynamicValue<CGSize>, Binding>(parse: { binding -> Optional<DynamicValue<CGSize>> in if case .shadowOffset(let x) = binding { return x } else { return nil } }) }
	static var preferredMaxLayoutWidth: BindingParser<DynamicValue<CGFloat>, Binding> { return BindingParser<DynamicValue<CGFloat>, Binding>(parse: { binding -> Optional<DynamicValue<CGFloat>> in if case .preferredMaxLayoutWidth(let x) = binding { return x } else { return nil } }) }
}

// MARK: ### CwlNavigationItemTesting.swift ###

extension BindingParser where Binding == NavigationItem.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	static var title: BindingParser<DynamicValue<String>, Binding> { return BindingParser<DynamicValue<String>, Binding>(parse: { binding -> Optional<DynamicValue<String>> in if case .title(let x) = binding { return x } else { return nil } }) }
	static var titleView: BindingParser<DynamicValue<ViewConvertible?>, Binding> { return BindingParser<DynamicValue<ViewConvertible?>, Binding>(parse: { binding -> Optional<DynamicValue<ViewConvertible?>> in if case .titleView(let x) = binding { return x } else { return nil } }) }
	static var prompt: BindingParser<DynamicValue<String?>, Binding> { return BindingParser<DynamicValue<String?>, Binding>(parse: { binding -> Optional<DynamicValue<String?>> in if case .prompt(let x) = binding { return x } else { return nil } }) }
	static var backBarButtonItem: BindingParser<DynamicValue<BarButtonItemConvertible?>, Binding> { return BindingParser<DynamicValue<BarButtonItemConvertible?>, Binding>(parse: { binding -> Optional<DynamicValue<BarButtonItemConvertible?>> in if case .backBarButtonItem(let x) = binding { return x } else { return nil } }) }
	static var hidesBackButton: BindingParser<DynamicValue<SetOrAnimate<Bool>>, Binding> { return BindingParser<DynamicValue<SetOrAnimate<Bool>>, Binding>(parse: { binding -> Optional<DynamicValue<SetOrAnimate<Bool>>> in if case .hidesBackButton(let x) = binding { return x } else { return nil } }) }
	static var leftBarButtonItems: BindingParser<DynamicValue<SetOrAnimate<[BarButtonItemConvertible]>>, Binding> { return BindingParser<DynamicValue<SetOrAnimate<[BarButtonItemConvertible]>>, Binding>(parse: { binding -> Optional<DynamicValue<SetOrAnimate<[BarButtonItemConvertible]>>> in if case .leftBarButtonItems(let x) = binding { return x } else { return nil } }) }
	static var rightBarButtonItems: BindingParser<DynamicValue<SetOrAnimate<[BarButtonItemConvertible]>>, Binding> { return BindingParser<DynamicValue<SetOrAnimate<[BarButtonItemConvertible]>>, Binding>(parse: { binding -> Optional<DynamicValue<SetOrAnimate<[BarButtonItemConvertible]>>> in if case .rightBarButtonItems(let x) = binding { return x } else { return nil } }) }
	static var leftItemsSupplementBackButton: BindingParser<DynamicValue<Bool>, Binding> { return BindingParser<DynamicValue<Bool>, Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .leftItemsSupplementBackButton(let x) = binding { return x } else { return nil } }) }
}

// MARK: ### CwlViewTesting.swift ###

extension BindingParser where Binding == View.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }

	static var layer: BindingParser<StaticValue<BackingLayer>, Binding> { return BindingParser<StaticValue<BackingLayer>, Binding>(parse: { binding -> Optional<StaticValue<BackingLayer>> in if case .layer(let x) = binding { return x } else { return nil } }) }

	// 1. Value bindings may be applied at construction and may subsequently change.
	static var layout: BindingParser<DynamicValue<Layout>, Binding> { return BindingParser<DynamicValue<Layout>, Binding>(parse: { binding -> Optional<DynamicValue<Layout>> in if case .layout(let x) = binding { return x } else { return nil } }) }
	static var backgroundColor: BindingParser<DynamicValue<(UIColor?)>, Binding> { return BindingParser<DynamicValue<(UIColor?)>, Binding>(parse: { binding -> Optional<DynamicValue<(UIColor?)>> in if case .backgroundColor(let x) = binding { return x } else { return nil } }) }
	static var isHidden: BindingParser<DynamicValue<(Bool)>, Binding> { return BindingParser<DynamicValue<(Bool)>, Binding>(parse: { binding -> Optional<DynamicValue<(Bool)>> in if case .isHidden(let x) = binding { return x } else { return nil } }) }
	static var alpha: BindingParser<DynamicValue<(CGFloat)>, Binding> { return BindingParser<DynamicValue<(CGFloat)>, Binding>(parse: { binding -> Optional<DynamicValue<(CGFloat)>> in if case .alpha(let x) = binding { return x } else { return nil } }) }
	static var isOpaque: BindingParser<DynamicValue<(Bool)>, Binding> { return BindingParser<DynamicValue<(Bool)>, Binding>(parse: { binding -> Optional<DynamicValue<(Bool)>> in if case .isOpaque(let x) = binding { return x } else { return nil } }) }
	static var tintColor: BindingParser<DynamicValue<(UIColor)>, Binding> { return BindingParser<DynamicValue<(UIColor)>, Binding>(parse: { binding -> Optional<DynamicValue<(UIColor)>> in if case .tintColor(let x) = binding { return x } else { return nil } }) }
	static var tintAdjustmentMode: BindingParser<DynamicValue<(UIViewTintAdjustmentMode)>, Binding> { return BindingParser<DynamicValue<(UIViewTintAdjustmentMode)>, Binding>(parse: { binding -> Optional<DynamicValue<(UIViewTintAdjustmentMode)>> in if case .tintAdjustmentMode(let x) = binding { return x } else { return nil } }) }
	static var clipsToBounds: BindingParser<DynamicValue<(Bool)>, Binding> { return BindingParser<DynamicValue<(Bool)>, Binding>(parse: { binding -> Optional<DynamicValue<(Bool)>> in if case .clipsToBounds(let x) = binding { return x } else { return nil } }) }
	static var clearsContextBeforeDrawing: BindingParser<DynamicValue<(Bool)>, Binding> { return BindingParser<DynamicValue<(Bool)>, Binding>(parse: { binding -> Optional<DynamicValue<(Bool)>> in if case .clearsContextBeforeDrawing(let x) = binding { return x } else { return nil } }) }
	static var mask: BindingParser<DynamicValue<(ViewConvertible?)>, Binding> { return BindingParser<DynamicValue<(ViewConvertible?)>, Binding>(parse: { binding -> Optional<DynamicValue<(ViewConvertible?)>> in if case .mask(let x) = binding { return x } else { return nil } }) }
	static var isUserInteractionEnabled: BindingParser<DynamicValue<(Bool)>, Binding> { return BindingParser<DynamicValue<(Bool)>, Binding>(parse: { binding -> Optional<DynamicValue<(Bool)>> in if case .isUserInteractionEnabled(let x) = binding { return x } else { return nil } }) }
	static var isMultipleTouchEnabled: BindingParser<DynamicValue<(Bool)>, Binding> { return BindingParser<DynamicValue<(Bool)>, Binding>(parse: { binding -> Optional<DynamicValue<(Bool)>> in if case .isMultipleTouchEnabled(let x) = binding { return x } else { return nil } }) }
	static var isExclusiveTouch: BindingParser<DynamicValue<(Bool)>, Binding> { return BindingParser<DynamicValue<(Bool)>, Binding>(parse: { binding -> Optional<DynamicValue<(Bool)>> in if case .isExclusiveTouch(let x) = binding { return x } else { return nil } }) }
	static var contentMode: BindingParser<DynamicValue<(UIViewContentMode)>, Binding> { return BindingParser<DynamicValue<(UIViewContentMode)>, Binding>(parse: { binding -> Optional<DynamicValue<(UIViewContentMode)>> in if case .contentMode(let x) = binding { return x } else { return nil } }) }
	static var horizontalContentCompressionResistancePriority: BindingParser<DynamicValue<UILayoutPriority>, Binding> { return BindingParser<DynamicValue<UILayoutPriority>, Binding>(parse: { binding -> Optional<DynamicValue<UILayoutPriority>> in if case .horizontalContentCompressionResistancePriority(let x) = binding { return x } else { return nil } }) }
	static var verticalContentCompressionResistancePriority: BindingParser<DynamicValue<UILayoutPriority>, Binding> { return BindingParser<DynamicValue<UILayoutPriority>, Binding>(parse: { binding -> Optional<DynamicValue<UILayoutPriority>> in if case .verticalContentCompressionResistancePriority(let x) = binding { return x } else { return nil } }) }
	static var horizontalContentHuggingPriority: BindingParser<DynamicValue<UILayoutPriority>, Binding> { return BindingParser<DynamicValue<UILayoutPriority>, Binding>(parse: { binding -> Optional<DynamicValue<UILayoutPriority>> in if case .horizontalContentHuggingPriority(let x) = binding { return x } else { return nil } }) }
	static var verticalContentHuggingPriority: BindingParser<DynamicValue<UILayoutPriority>, Binding> { return BindingParser<DynamicValue<UILayoutPriority>, Binding>(parse: { binding -> Optional<DynamicValue<UILayoutPriority>> in if case .verticalContentHuggingPriority(let x) = binding { return x } else { return nil } }) }
	static var semanticContentAttribute: BindingParser<DynamicValue<(UISemanticContentAttribute)>, Binding> { return BindingParser<DynamicValue<(UISemanticContentAttribute)>, Binding>(parse: { binding -> Optional<DynamicValue<(UISemanticContentAttribute)>> in if case .semanticContentAttribute(let x) = binding { return x } else { return nil } }) }
	static var layoutMargins: BindingParser<DynamicValue<(UIEdgeInsets)>, Binding> { return BindingParser<DynamicValue<(UIEdgeInsets)>, Binding>(parse: { binding -> Optional<DynamicValue<(UIEdgeInsets)>> in if case .layoutMargins(let x) = binding { return x } else { return nil } }) }
	static var preservesSuperviewLayoutMargins: BindingParser<DynamicValue<(Bool)>, Binding> { return BindingParser<DynamicValue<(Bool)>, Binding>(parse: { binding -> Optional<DynamicValue<(Bool)>> in if case .preservesSuperviewLayoutMargins(let x) = binding { return x } else { return nil } }) }
	static var gestureRecognizers: BindingParser<DynamicValue<[UIGestureRecognizer]>, Binding> { return BindingParser<DynamicValue<[UIGestureRecognizer]>, Binding>(parse: { binding -> Optional<DynamicValue<[UIGestureRecognizer]>> in if case .gestureRecognizers(let x) = binding { return x } else { return nil } }) }
	static var motionEffects: BindingParser<DynamicValue<([UIMotionEffect])>, Binding> { return BindingParser<DynamicValue<([UIMotionEffect])>, Binding>(parse: { binding -> Optional<DynamicValue<([UIMotionEffect])>> in if case .motionEffects(let x) = binding { return x } else { return nil } }) }
	static var tag: BindingParser<DynamicValue<Int>, Binding> { return BindingParser<DynamicValue<Int>, Binding>(parse: { binding -> Optional<DynamicValue<Int>> in if case .tag(let x) = binding { return x } else { return nil } }) }
	static var restorationIdentifier: BindingParser<DynamicValue<String?>, Binding> { return BindingParser<DynamicValue<String?>, Binding>(parse: { binding -> Optional<DynamicValue<String?>> in if case .restorationIdentifier(let x) = binding { return x } else { return nil } }) }

	// 2. Signal bindings are performed on the object after construction.
	static var endEditing: BindingParser<Signal<Bool>, Binding> { return BindingParser<Signal<Bool>, Binding>(parse: { binding -> Optional<Signal<Bool>> in if case .endEditing(let x) = binding { return x } else { return nil } }) }
	static var becomeFirstResponder: BindingParser<Signal<()>, Binding> { return BindingParser<Signal<()>, Binding>(parse: { binding -> Optional<Signal<()>> in if case .becomeFirstResponder(let x) = binding { return x } else { return nil } }) }
}

// MARK: ### CwlBarButtonItemTesting.swift ###

extension BindingParser where Binding == BarButtonItem.Binding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	static var barButtonSystemItem: BindingParser<StaticValue<UIBarButtonSystemItem>, Binding> { return BindingParser<StaticValue<UIBarButtonSystemItem>, Binding>(parse: { binding -> Optional<StaticValue<UIBarButtonSystemItem>> in if case .barButtonSystemItem(let x) = binding { return x } else { return nil } }) }
	static var itemStyle: BindingParser<DynamicValue<UIBarButtonItemStyle>, Binding> { return BindingParser<DynamicValue<UIBarButtonItemStyle>, Binding>(parse: { binding -> Optional<DynamicValue<UIBarButtonItemStyle>> in if case .itemStyle(let x) = binding { return x } else { return nil } }) }
	static var possibleTitles: BindingParser<DynamicValue<Set<String>?>, Binding> { return BindingParser<DynamicValue<Set<String>?>, Binding>(parse: { binding -> Optional<DynamicValue<Set<String>?>> in if case .possibleTitles(let x) = binding { return x } else { return nil } }) }
	static var width: BindingParser<DynamicValue<CGFloat>, Binding> { return BindingParser<DynamicValue<CGFloat>, Binding>(parse: { binding -> Optional<DynamicValue<CGFloat>> in if case .width(let x) = binding { return x } else { return nil } }) }
	static var customView: BindingParser<DynamicValue<ViewConvertible?>, Binding> { return BindingParser<DynamicValue<ViewConvertible?>, Binding>(parse: { binding -> Optional<DynamicValue<ViewConvertible?>> in if case .customView(let x) = binding { return x } else { return nil } }) }
	static var tintColor: BindingParser<DynamicValue<UIColor?>, Binding> { return BindingParser<DynamicValue<UIColor?>, Binding>(parse: { binding -> Optional<DynamicValue<UIColor?>> in if case .tintColor(let x) = binding { return x } else { return nil } }) }
	static var backgroundImage: BindingParser<DynamicValue<ScopedValues<StateStyleAndMetrics, UIImage?>>, Binding> { return BindingParser<DynamicValue<ScopedValues<StateStyleAndMetrics, UIImage?>>, Binding>(parse: { binding -> Optional<DynamicValue<ScopedValues<StateStyleAndMetrics, UIImage?>>> in if case .backgroundImage(let x) = binding { return x } else { return nil } }) }
	static var backButtonBackgroundImage: BindingParser<DynamicValue<ScopedValues<StateAndMetrics, UIImage?>>, Binding> { return BindingParser<DynamicValue<ScopedValues<StateAndMetrics, UIImage?>>, Binding>(parse: { binding -> Optional<DynamicValue<ScopedValues<StateAndMetrics, UIImage?>>> in if case .backButtonBackgroundImage(let x) = binding { return x } else { return nil } }) }
	static var backButtonTitlePositionAdjustment: BindingParser<DynamicValue<ScopedValues<UIBarMetrics, UIOffset>>, Binding> { return BindingParser<DynamicValue<ScopedValues<UIBarMetrics, UIOffset>>, Binding>(parse: { binding -> Optional<DynamicValue<ScopedValues<UIBarMetrics, UIOffset>>> in if case .backButtonTitlePositionAdjustment(let x) = binding { return x } else { return nil } }) }
	static var backgroundVerticalPositionAdjustment: BindingParser<DynamicValue<ScopedValues<UIBarMetrics, CGFloat>>, Binding> { return BindingParser<DynamicValue<ScopedValues<UIBarMetrics, CGFloat>>, Binding>(parse: { binding -> Optional<DynamicValue<ScopedValues<UIBarMetrics, CGFloat>>> in if case .backgroundVerticalPositionAdjustment(let x) = binding { return x } else { return nil } }) }
	static var titlePositionAdjustment: BindingParser<DynamicValue<ScopedValues<UIBarMetrics, UIOffset>>, Binding> { return BindingParser<DynamicValue<ScopedValues<UIBarMetrics, UIOffset>>, Binding>(parse: { binding -> Optional<DynamicValue<ScopedValues<UIBarMetrics, UIOffset>>> in if case .titlePositionAdjustment(let x) = binding { return x } else { return nil } }) }
	static var action: BindingParser<TargetAction<()>, Binding> { return BindingParser<TargetAction<()>, Binding>(parse: { binding -> Optional<TargetAction<()>> in if case .action(let x) = binding { return x } else { return nil } }) }
}

// MARK: ### CwlTableViewTesting.swift ###

extension TableViewBinding {
	static func tableStructure<S: Sequence>(in bindings: S) throws -> TableRowState<TableSectionState<RowDataType>> where S.Element == TableView<RowDataType>.Binding {
		var found: TableRowState<TableSectionState<RowDataType>>? = nil
		for b in bindings {
			if case .tableData(let x) = b {
				if found != nil {
					throw BindingParserErrors.multipleMatchesFound
				}
				let values = x.captureValues()
				var sections = TableRowState<TableSectionState<RowDataType>>()
				for v in values {
					v.apply(to: &sections)
				}
				found = sections
			}
		}
		if let f = found {
			return f
		}
		throw BindingParserErrors.noMatchesFound
	}
}

extension BindingParser where Binding: TableViewBinding {
	// You can easily convert the `Binding` cases to `BindingParser` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    static var $1: BindingParser<$2, Binding> { return BindingParser<$2, Binding>(parse: { binding -> Optional<$2> in if case .$1(let x) = binding { return x } else { return nil } }) }
	
	//	0. Static bindings are applied at construction and are subsequently immutable.
	static var tableViewStyle: BindingParser<StaticValue<UITableViewStyle>, TableView<Binding.RowDataType>.Binding> { return BindingParser<StaticValue<UITableViewStyle>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<StaticValue<UITableViewStyle>> in if case .tableViewStyle(let x) = binding { return x } else { return nil } }) }

	//	1. Value bindings may be applied at construction and may subsequently change.
	static var allowsMultipleSelection: BindingParser<DynamicValue<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .allowsMultipleSelection(let x) = binding { return x } else { return nil } }) }
	static var allowsMultipleSelectionDuringEditing: BindingParser<DynamicValue<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .allowsMultipleSelectionDuringEditing(let x) = binding { return x } else { return nil } }) }
	static var allowsSelection: BindingParser<DynamicValue<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .allowsSelection(let x) = binding { return x } else { return nil } }) }
	static var allowsSelectionDuringEditing: BindingParser<DynamicValue<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .allowsSelectionDuringEditing(let x) = binding { return x } else { return nil } }) }
	static var backgroundView: BindingParser<DynamicValue<ViewConvertible?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<ViewConvertible?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<ViewConvertible?>> in if case .backgroundView(let x) = binding { return x } else { return nil } }) }
	static var cellLayoutMarginsFollowReadableWidth: BindingParser<DynamicValue<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .cellLayoutMarginsFollowReadableWidth(let x) = binding { return x } else { return nil } }) }
	static var isEditing: BindingParser<Signal<SetOrAnimate<Bool>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<Bool>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<Bool>>> in if case .isEditing(let x) = binding { return x } else { return nil } }) }
	static var estimatedRowHeight: BindingParser<DynamicValue<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<CGFloat>> in if case .estimatedRowHeight(let x) = binding { return x } else { return nil } }) }
	static var estimatedSectionFooterHeight: BindingParser<DynamicValue<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<CGFloat>> in if case .estimatedSectionFooterHeight(let x) = binding { return x } else { return nil } }) }
	static var estimatedSectionHeaderHeight: BindingParser<DynamicValue<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<CGFloat>> in if case .estimatedSectionHeaderHeight(let x) = binding { return x } else { return nil } }) }
	static var remembersLastFocusedIndexPath: BindingParser<DynamicValue<Bool>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<Bool>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<Bool>> in if case .remembersLastFocusedIndexPath(let x) = binding { return x } else { return nil } }) }
	static var rowHeight: BindingParser<DynamicValue<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<CGFloat>> in if case .rowHeight(let x) = binding { return x } else { return nil } }) }
	static var sectionFooterHeight: BindingParser<DynamicValue<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<CGFloat>> in if case .sectionFooterHeight(let x) = binding { return x } else { return nil } }) }
	static var sectionHeaderHeight: BindingParser<DynamicValue<CGFloat>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<CGFloat>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<CGFloat>> in if case .sectionHeaderHeight(let x) = binding { return x } else { return nil } }) }
	static var sectionIndexBackgroundColor: BindingParser<DynamicValue<UIColor?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<UIColor?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<UIColor?>> in if case .sectionIndexBackgroundColor(let x) = binding { return x } else { return nil } }) }
	static var sectionIndexColor: BindingParser<DynamicValue<UIColor?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<UIColor?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<UIColor?>> in if case .sectionIndexColor(let x) = binding { return x } else { return nil } }) }
	static var sectionIndexMinimumDisplayRowCount: BindingParser<DynamicValue<Int>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<Int>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<Int>> in if case .sectionIndexMinimumDisplayRowCount(let x) = binding { return x } else { return nil } }) }
	static var sectionIndexTrackingBackgroundColor: BindingParser<DynamicValue<UIColor?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<UIColor?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<UIColor?>> in if case .sectionIndexTrackingBackgroundColor(let x) = binding { return x } else { return nil } }) }
	static var sectionIndexTitles: BindingParser<DynamicValue<[String]?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<[String]?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<[String]?>> in if case .sectionIndexTitles(let x) = binding { return x } else { return nil } }) }
	static var separatorColor: BindingParser<DynamicValue<UIColor?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<UIColor?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<UIColor?>> in if case .separatorColor(let x) = binding { return x } else { return nil } }) }
	static var separatorEffect: BindingParser<DynamicValue<UIVisualEffect?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<UIVisualEffect?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<UIVisualEffect?>> in if case .separatorEffect(let x) = binding { return x } else { return nil } }) }
	static var separatorInset: BindingParser<DynamicValue<UIEdgeInsets>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<UIEdgeInsets>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<UIEdgeInsets>> in if case .separatorInset(let x) = binding { return x } else { return nil } }) }
	static var separatorStyle: BindingParser<DynamicValue<UITableViewCellSeparatorStyle>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<UITableViewCellSeparatorStyle>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<UITableViewCellSeparatorStyle>> in if case .separatorStyle(let x) = binding { return x } else { return nil } }) }
	static var tableFooterView: BindingParser<DynamicValue<ViewConvertible?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<ViewConvertible?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<ViewConvertible?>> in if case .tableFooterView(let x) = binding { return x } else { return nil } }) }
	static var tableHeaderView: BindingParser<DynamicValue<ViewConvertible?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<ViewConvertible?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<ViewConvertible?>> in if case .tableHeaderView(let x) = binding { return x } else { return nil } }) }
	static var tableData: BindingParser<DynamicValue<TableData<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<DynamicValue<TableData<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<DynamicValue<TableData<Binding.RowDataType>>> in if case .tableData(let x) = binding { return x } else { return nil } }) }
	
	//	2. Signal bindings are performed on the object after construction.
	static var deselectRow: BindingParser<Signal<SetOrAnimate<IndexPath>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<IndexPath>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<IndexPath>>> in if case .deselectRow(let x) = binding { return x } else { return nil } }) }
	static var scrollToNearestSelectedRow: BindingParser<Signal<SetOrAnimate<UITableViewScrollPosition>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<UITableViewScrollPosition>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<UITableViewScrollPosition>>> in if case .scrollToNearestSelectedRow(let x) = binding { return x } else { return nil } }) }
	static var scrollToRow: BindingParser<Signal<SetOrAnimate<TableScrollPosition>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<TableScrollPosition>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<TableScrollPosition>>> in if case .scrollToRow(let x) = binding { return x } else { return nil } }) }
	static var selectRow: BindingParser<Signal<SetOrAnimate<TableScrollPosition?>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<Signal<SetOrAnimate<TableScrollPosition?>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<Signal<SetOrAnimate<TableScrollPosition?>>> in if case .selectRow(let x) = binding { return x } else { return nil } }) }
	
	//	3. Action bindings are triggered by the object after construction.
	static var userDidScrollToRow: BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>>> in if case .userDidScrollToRow(let x) = binding { return x } else { return nil } }) }
	static var accessoryButtonTapped: BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>>> in if case .accessoryButtonTapped(let x) = binding { return x } else { return nil } }) }
	static var didDeselectRow: BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>>> in if case .didDeselectRow(let x) = binding { return x } else { return nil } }) }
	static var didEndDisplayingFooter: BindingParser<SignalInput<Int>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<Int>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<Int>> in if case .didEndDisplayingFooter(let x) = binding { return x } else { return nil } }) }
	static var didEndDisplayingHeader: BindingParser<SignalInput<Int>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<Int>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<Int>> in if case .didEndDisplayingHeader(let x) = binding { return x } else { return nil } }) }
	static var didEndDisplayingRow: BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>>> in if case .didEndDisplayingRow(let x) = binding { return x } else { return nil } }) }
	static var didEndEditingRow: BindingParser<SignalInput<TableRow<Binding.RowDataType>?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>?>> in if case .didEndEditingRow(let x) = binding { return x } else { return nil } }) }
	static var didHightlightRow: BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>>> in if case .didHightlightRow(let x) = binding { return x } else { return nil } }) }
	static var didSelectRow: BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>>> in if case .didSelectRow(let x) = binding { return x } else { return nil } }) }
	static var didUnhighlightRow: BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<TableRow<Binding.RowDataType>>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<TableRow<Binding.RowDataType>>> in if case .didUnhighlightRow(let x) = binding { return x } else { return nil } }) }
	static var moveRow: BindingParser<SignalInput<(from: TableRow<Binding.RowDataType>, to: IndexPath)>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<(from: TableRow<Binding.RowDataType>, to: IndexPath)>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<(from: TableRow<Binding.RowDataType>, to: IndexPath)>> in if case .moveRow(let x) = binding { return x } else { return nil } }) }
	static var selectionDidChange: BindingParser<SignalInput<[TableRow<Binding.RowDataType>]?>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<[TableRow<Binding.RowDataType>]?>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<[TableRow<Binding.RowDataType>]?>> in if case .selectionDidChange(let x) = binding { return x } else { return nil } }) }
	static var visibleRowsChanged: BindingParser<SignalInput<[TableRow<Binding.RowDataType>]>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<[TableRow<Binding.RowDataType>]>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<[TableRow<Binding.RowDataType>]>> in if case .visibleRowsChanged(let x) = binding { return x } else { return nil } }) }
	static var commit: BindingParser<SignalInput<(editingStyle: UITableViewCellEditingStyle, row: TableRow<Binding.RowDataType>)>, TableView<Binding.RowDataType>.Binding> { return BindingParser<SignalInput<(editingStyle: UITableViewCellEditingStyle, row: TableRow<Binding.RowDataType>)>, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<SignalInput<(editingStyle: UITableViewCellEditingStyle, row: TableRow<Binding.RowDataType>)>> in if case .commit(let x) = binding { return x } else { return nil } }) }
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	static var cellIdentifier: BindingParser<(TableRow<Binding.RowDataType>) -> String?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(TableRow<Binding.RowDataType>) -> String?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(TableRow<Binding.RowDataType>) -> String?> in if case .cellIdentifier(let x) = binding { return x } else { return nil } }) }
	static var canEditRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .canEditRow(let x) = binding { return x } else { return nil } }) }
	static var canFocusRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .canFocusRow(let x) = binding { return x } else { return nil } }) }
	static var canMoveRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .canMoveRow(let x) = binding { return x } else { return nil } }) }
	static var canPerformAction: BindingParser<(_ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool> in if case .canPerformAction(let x) = binding { return x } else { return nil } }) }
	static var cellConstructor: BindingParser<(_ identifier: String?, _ rowSignal: SignalMulti<Binding.RowDataType>) -> TableViewCellConvertible, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ identifier: String?, _ rowSignal: SignalMulti<Binding.RowDataType>) -> TableViewCellConvertible, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ identifier: String?, _ rowSignal: SignalMulti<Binding.RowDataType>) -> TableViewCellConvertible> in if case .cellConstructor(let x) = binding { return x } else { return nil } }) }
	static var dataMissingCell: BindingParser<(IndexPath) -> TableViewCellConvertible, TableView<Binding.RowDataType>.Binding> { return BindingParser<(IndexPath) -> TableViewCellConvertible, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(IndexPath) -> TableViewCellConvertible> in if case .dataMissingCell(let x) = binding { return x } else { return nil } }) }
	static var didUpdateFocus: BindingParser<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void> in if case .didUpdateFocus(let x) = binding { return x } else { return nil } }) }
	static var editActionsForRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?> in if case .editActionsForRow(let x) = binding { return x } else { return nil } }) }
	static var editingStyleForRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCellEditingStyle, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCellEditingStyle, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCellEditingStyle> in if case .editingStyleForRow(let x) = binding { return x } else { return nil } }) }
	static var estimatedHeightForFooter: BindingParser<(_ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ section: Int) -> CGFloat> in if case .estimatedHeightForFooter(let x) = binding { return x } else { return nil } }) }
	static var estimatedHeightForHeader: BindingParser<(_ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ section: Int) -> CGFloat> in if case .estimatedHeightForHeader(let x) = binding { return x } else { return nil } }) }
	static var estimatedHeightForRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat> in if case .estimatedHeightForRow(let x) = binding { return x } else { return nil } }) }
	static var footerHeight: BindingParser<(_ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ section: Int) -> CGFloat> in if case .footerHeight(let x) = binding { return x } else { return nil } }) }
	static var footerView: BindingParser<(_ section: Int, _ title: String?) -> ViewConvertible?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ section: Int, _ title: String?) -> ViewConvertible?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ section: Int, _ title: String?) -> ViewConvertible?> in if case .footerView(let x) = binding { return x } else { return nil } }) }
	static var headerHeight: BindingParser<(_ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ section: Int) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ section: Int) -> CGFloat> in if case .headerHeight(let x) = binding { return x } else { return nil } }) }
	static var headerView: BindingParser<(_ section: Int, _ title: String?) -> ViewConvertible?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ section: Int, _ title: String?) -> ViewConvertible?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ section: Int, _ title: String?) -> ViewConvertible?> in if case .headerView(let x) = binding { return x } else { return nil } }) }
	static var heightForRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat> in if case .heightForRow(let x) = binding { return x } else { return nil } }) }
	static var indentationLevelForRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Int, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Int, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> Int> in if case .indentationLevelForRow(let x) = binding { return x } else { return nil } }) }
	static var indexPathForPreferredFocusedView: BindingParser<(UITableView) -> IndexPath, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView) -> IndexPath, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView) -> IndexPath> in if case .indexPathForPreferredFocusedView(let x) = binding { return x } else { return nil } }) }
	static var shouldHighlightRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .shouldHighlightRow(let x) = binding { return x } else { return nil } }) }
	static var shouldIndentWhileEditingRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .shouldIndentWhileEditingRow(let x) = binding { return x } else { return nil } }) }
	static var shouldShowMenuForRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool> in if case .shouldShowMenuForRow(let x) = binding { return x } else { return nil } }) }
	static var shouldUpdateFocus: BindingParser<(UITableView, UITableViewFocusUpdateContext) -> Bool, TableView<Binding.RowDataType>.Binding> { return BindingParser<(UITableView, UITableViewFocusUpdateContext) -> Bool, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(UITableView, UITableViewFocusUpdateContext) -> Bool> in if case .shouldUpdateFocus(let x) = binding { return x } else { return nil } }) }
	static var targetIndexPathForMoveFromRow: BindingParser<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath> in if case .targetIndexPathForMoveFromRow(let x) = binding { return x } else { return nil } }) }
	static var titleForDeleteConfirmationButtonForRow: BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> String?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableRowData: TableRow<Binding.RowDataType>) -> String?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableRowData: TableRow<Binding.RowDataType>) -> String?> in if case .titleForDeleteConfirmationButtonForRow(let x) = binding { return x } else { return nil } }) }
	static var willBeginEditingRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void> in if case .willBeginEditingRow(let x) = binding { return x } else { return nil } }) }
	static var willDeselectRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?> in if case .willDeselectRow(let x) = binding { return x } else { return nil } }) }
	static var willDisplayFooter: BindingParser<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void> in if case .willDisplayFooter(let x) = binding { return x } else { return nil } }) }
	static var willDisplayHeader: BindingParser<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void> in if case .willDisplayHeader(let x) = binding { return x } else { return nil } }) }
	static var willDisplayRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void> in if case .willDisplayRow(let x) = binding { return x } else { return nil } }) }
	static var willSelectRow: BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, TableView<Binding.RowDataType>.Binding> { return BindingParser<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, TableView<Binding.RowDataType>.Binding>(parse: { binding -> Optional<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?> in if case .willSelectRow(let x) = binding { return x } else { return nil } }) }
}
